local printlog = npe_logging.Printlog_npe
local printdebug = npe_logging.Printdebug_npe
local printtrace = npe_logging.Printtrace_npe
local print_table = npe_logging.Print_table_npe
local debug_table = npe_logging.Debug_table_npe
local print_functor = npe_logging.Print_functor_npe
local LOG = npe_logging
-------------------------------------------------- NPE Data Structures --------------------------------------------------

-- this queue is populated at startup from other npe modules when available otherwise it will only have the npe tutorial module
local npeConfig = {
    decks = {},
}

-- this queue is populated at first actor update and when the MCM settings are changed
-- this queue is populated according to the settings in the MCM
local npeSetsActivationQueue = {
    contexts = {},
}

-- this queue is populated by activated contexts
local playableQueue = {
    setsKeys = {},
}
function get_playableQueue()
    return playableQueue.setsKeys
end 

-- this queue is populated by activated contexts
local playableHighPrioQueue = {
    setsKeys = {},
}
function get_playableHighPrioQueue()
    return playableHighPrioQueue.setsKeys
end

-- this queue is populated by activated contexts with a delay
local playableOnCountdownQueue = {
    setsKeys = {},
}
function get_playableOnCountdownQueue()
    return playableOnCountdownQueue.setsKeys
end

-- this queue is populated from contexts defined in sets
local npeExecutionQueue = {
    handlers = {},
}
function get_npeExecutionQueue()
    return npeExecutionQueue.handlers
end

-- this queue is populated by actions defined in sets (and cards?)
local npeActionsQueue = {
    actions = {},
}
function get_npeActionsQueue()
    return npeActionsQueue.actions
end

local Runner ={}

Settings = {
    enable = true,
    execution_loop = 3,
    actions_execution_loop = 1,
    play_loop = 10,
    sounds_set = "NPE",
    pause_game = false,
}

RegisteredCustomCallbacks = {}

-- NPE FLAGS
Dialog_in_use = false
Dialog_name = nil

-------------------------------------------------- NPE Utils --------------------------------------------------

-------------------------------------------------- Tables --------------------------------------------------

function clone (t) -- deep-copy a table
    if type(t) ~= "table" then return t end
    local meta = getmetatable(t)
    local target = {}
    for k, v in pairs(t) do
        if type(v) == "table" then
            target[k] = clone(v)
        else
            target[k] = v
        end
    end
    setmetatable(target, meta)
    return target
end

-------------------------------------------------- NPE hashing functions --------------------------------------------------

local function map_to_set_key(deckId, setId)
    return deckId .. "/" .. setId
end

local function map_from_set_key(key)
    local split = string.gmatch(key, "[^/]+")
    local deckId = split()
    local setId = split()
    return deckId, setId
end

local function get_set_from_key(key)
    local deckId, setId = map_from_set_key(key)
    local deck = npeConfig.decks[deckId]
    if deck ~= nil then
        return deck.sets[setId], deckId, deck.module, deck.dialog
    end
    return nil
end

-------------------------------------------------- NPE Modules registration -------------------------------------------------- 

local function add_deck(npeDeck)
    if npeDeck ~= nil then
        if npeConfig.decks[npeDeck.id] == nil then
            local indexedSets = {}
            for _, set in pairs(npeDeck.sets) do
                if not set.disabled then
                indexedSets[set.id] = set
                end
            end
            npeDeck.sets = indexedSets
            npeConfig.decks[npeDeck.id] = npeDeck
        else
            printlog(LOG.ERROR, LOG.CONF,"Deck with id [" .. npeDeck.id .. "] already exists.")
        end
    end
end

function Register_npe_module(deck)

    printlog(LOG.ADD, LOG.RGSTR,"[".. deck.id .. "] Adding deck " .. deck.title .. " to NPE Manager.")
    add_deck(deck)
end

-------------------------------------------------- NPE MCM State Updates --------------------------------------------------

local function update_set_played_state(set, played)
    set.played = played
    npe_mcm.npe_module_set_setting(set.module, set.id, true)
end

-------------------------------------------------- NPE decks update from MCM --------------------------------------------------

local function update_decks_from_mcm()
    printlog(LOG.ADD, LOG.CONF," Update decks from MCM")
    for deckId, deck in pairs(npeConfig.decks) do
        for setId, set in pairs(deck.sets) do
            set.played = npe_mcm.npe_module_get_setting(deck.module, set.id)
            if set.context.event.handler.executed then
                set.context.event.handler.executed = false
            end
            if set.context.countdown then
                set.context.countdown = nil
            end
        end
    end
end

-------------------------------------------------- NPE decks override --------------------------------------------------

local function override_cards(set, overrideTargetSet)
    for cardKey, card in pairs(set.cards) do
        if overrideTargetSet.cards[cardKey] ~= nil then
            for fieldKey, fieldValue in pairs(card) do
                if fieldValue ~= nil then
                    printlog(LOG.INFO, LOG.OVERR," Override card [%s] field [%s] with value [%s]", cardKey, fieldKey, fieldValue)
                    overrideTargetSet.cards[cardKey][fieldKey] = fieldValue
                end
            end
        end
    end
    return overrideTargetSet
end

local function override_contexts(context, overrideTargetSet)
    overrideTargetSet.context = {}
    for contextKey, contextValue in pairs(context) do
        if contextKey ~= "override" and contextValue ~= nil then
            printdebug(LOG.INFO, LOG.OVERR," Override context [%s] with value [%s]", contextKey, contextValue)
            overrideTargetSet.context[contextKey] = contextValue
        end
    end
    return overrideTargetSet
end

local function apply_overrides_to_decks()
    printdebug(LOG.RUN, LOG.OVERR," Apply overrides to decks")
    for deckId, deck in pairs(npeConfig.decks) do
        printdebug(LOG.RUN, LOG.OVERR," Searching into Deck [%s]:", deckId)
        for setId, set in pairs(deck.sets) do
            printdebug(LOG.RUN, LOG.OVERR," Searching into Set [%s] played [%s]:", setId, set.played)
            if set.context and set.context.override then

                printdebug(LOG.RUN, LOG.OVERR," Set [%s] has override rules:", setId)
                debug_table(set.context.event.override)

                local override = set.context.override

                if npeConfig.decks[override.deckId] and npeConfig.decks[override.deckId].sets[override.setId] then
                    
                    local overrideTemplateSet = clone(npeConfig.decks[override.deckId].sets[override.setId])

                    -- inheriting the played state from the overrider set
                    overrideTemplateSet.played = set.played

                    printdebug(LOG.RUN, LOG.OVERR," Override set [%s] data with content from set [%s]", override.setId, set.id)

                    overrideTemplateSet = override_cards(set, overrideTemplateSet)
                    if set.title then
                        overrideTemplateSet.title = set.title
                        printdebug(LOG.INFO, LOG.OVERR," Override set [%s] title with [%s]", override.setId, set.title)
                    end
                    
                    overrideTemplateSet = override_contexts(set.context, overrideTemplateSet)

                    -- update the npeConfig.decks table with the new changes
                    npeConfig.decks[deckId].sets[setId] = overrideTemplateSet
                    npeConfig.decks[deckId].sets[setId].id = setId
                    npeConfig.decks[override.deckId].sets[override.setId].overridden = true
                else
                    printlog("![NPE][OVERR] Deck with id [%s] or Set with id [%s] to for overriding, does not exist.", override.deckId, override.setId)
                end
            end
        end
    end
end

-------------------------------------------------- NPE Queues -------------------------------------------------- 

local function compare_events(event1, event2)
    if event1.name ~= event2.name then
        return false
    end
    if event1.module ~= event2.module then
        return false
    end
    return true
end

local function find_sets_on(event)
    printdebug(LOG.RUN, LOG.ACTIV," Find queued contexts activating on event [%s]", event.name)
    local setsKeys = {}
    for setKey, queued_context in pairs(npeSetsActivationQueue.contexts) do
        if compare_events(queued_context.event, event) then
            printtrace(LOG.INFO, LOG.ACTIV," queued context [%s]", setKey)
            table.insert(setsKeys, setKey)
        end
    end
    return setsKeys
end

local function add_to_sets_queue(set, deckId, module)
    printdebug(LOG.ADD, LOG.QUEUE," Add sets to activation queue: [%s] [%s]", deckId, set.id)
    local setKey = map_to_set_key(deckId, set.id)
    printtrace(LOG.INFO, LOG.QUEUE," setKey [%s]", setKey)
    if set ~= nil then

        -- Create a context table with the event and delay from the set
        local context = {
            event = set.context.event,
            delay = set.context.delay,
            pause_game = set.context.pause_game,
        }
        if not context.event.handler.module then
            context.event.handler.module = module
        end
        -- Check if a context with the same contextId already exists
            if npeSetsActivationQueue.contexts[setKey] == nil then
                -- Add the new context to the table with contextId as the key
                npeSetsActivationQueue.contexts[setKey] = context
                printtrace(LOG.INFO, LOG.QUEUE," context with id [" .. setKey .. "] added to the queue with event [" .. context.event.name .. "] and module [" .. context.event.handler.module .. "]")
            else 
            -- TODO we should use here THE context.override directive to replace the contexts
            printlog(LOG.ERROR, LOG.QUEUE," context with id [" .. setKey .. "] already exists.")
            printlog(LOG.ERROR, LOG.QUEUE," context event [" .. context.event.name .. "] and module [" .. context.event.handler.module .. "]")
            end
    end
end

local function add_to_playable_queue(setsKeys)
    if setsKeys == nil then
        return
    end
    for i, setKey in ipairs(setsKeys) do
        -- add set to the playable queue
        local set, deckId, module = get_set_from_key(setKey)
        if set then
            if set.context.delay then 
                if set.context.delay == 0 then
                    printdebug(LOG.ADD, LOG.QUEUE," Set [%s] plays instantly - Set added to the play_now queue", setKey)
                    table.insert(playableHighPrioQueue.setsKeys, setKey)                
                else 
                    printdebug(LOG.ADD, LOG.QUEUE," Set [%s] has a delay of [%s] - Set added to the countdown queue", setKey, set.context.delay)
                    table.insert(playableOnCountdownQueue.setsKeys, setKey)
                end
            else
                printdebug(LOG.ADD, LOG.QUEUE," Set [%s] plays with default play_loop - Set added to the play queue", setKey)
                table.insert(playableQueue.setsKeys, setKey)
            end
            -- removes it from the npeSetsActivationQueue
            npeSetsActivationQueue.contexts[setKey] = nil
        else
            printlog(LOG.ERROR, LOG.QUEUE," Set with key [%s] does not exist", setKey)
        end
    end
end

local function add_to_execution_queue(handler)
    printdebug(LOG.ADD, LOG.QUEUE," Add handler to execution queue")
    if handler == nil then
        return
    end
    table.insert(npeExecutionQueue.handlers, handler)
end

local function add_to_actions_queue(action)
    printdebug(LOG.ADD, LOG.QUEUE," Add action to actions queue")
    if action == nil then
        return
    end
    table.insert(npeActionsQueue.actions, action)
end

local function update_activation_queue()
    printdebug(LOG.RUN, LOG.QUEUE," Update activation queue")
    npeSetsActivationQueue = {
        contexts = {},
    }
    for deckId, deck in pairs(npeConfig.decks) do
        for setId, set in pairs(deck.sets) do
            -- Only call add_to_sets_queue if set is not overridden and has not played
            if not set.overridden and not set.played then
                add_to_sets_queue(set, deck.id, deck.module)
            end
        end
    end
end

-------------------------------------------------- NPE Dialogs and UI --------------------------------------------------

local function start_dialog(set)
    -- if dialog is null, use the default dialog
    if not set.dialog then
        set.dialog = npe.DIALOG.UI_TUTORIAL
    end
    printdebug(LOG.RUN, LOG.PLAY," Starting dialog [%s]",set.dialog )
    local dialog_functor = {set.dialog, "Play", set}
    execute_func(unpack(dialog_functor))
end

local function tear_down_dialog()
    printdebug(LOG.RUN, LOG.PLAY," Tear down dialog")
    local dialog_functor = {Dialog_name .. "_dialog", "TearDown"}
    execute_func(unpack(dialog_functor))
end

-- used by the dialog to register back to the NPE
function Register_dialog(dialog)
    Dialog_name = dialog
    Dialog_in_use = true
end
function Unregister_dialog()
    Dialog_name = nil
    Dialog_in_use = false
end

local function play_set_dialog(set)
    printdebug(LOG.RUN, LOG.PLAY," Playing set [%s] from module [%s]", set.id, set.module)
    printdebug(LOG.INFO, LOG.PLAY," Set Title: [%s]", set.title)

    update_set_played_state(set, true)

    Pause_Execution_Deprecated()

    start_dialog(set)
end

------------------------------------------ NPE Execution ------------------------------------------

-- npe runners configuration

local function update_runners_configs()
    Runner ={
        contexts_execution_queue = {
            name = "contexts_execution_queue",
            module = "npe_director",
            group_name = "default",
            execution = npe_execution.TYPE.QUEUE,
            queue = { "npe_director", "get_npeExecutionQueue"},
            start_timer = 0.25, 
            functor = { "npe_director", "run_npe_context_execution" }
        },        
        context_cooldown_queue = {
            name = "context_cooldown_queue",
            module = "npe_director",
            group_name = "default",
            execution = npe_execution.TYPE.QUEUE,
            queue = { "npe_director", "get_playableOnCountdownQueue"},
            start_timer = 1,  
            functor = { "npe_director", "update_all_npe_contexts_countdowns" }
        },
        actions_execution_queue = {
            name = "actions_execution_queue",
            module = "npe_director",
            group_name = "default",
            execution = npe_execution.TYPE.QUEUE,
            queue = { "npe_director", "get_npeActionsQueue"},
            start_timer = Settings.actions_execution_loop,   
            functor = { "npe_director", "run_npe_action" }
        },
        play_set_queue = {
            name = "play_set_queue",
            module = "npe_director",
            group_name = "play",
            execution = npe_execution.TYPE.QUEUE,
            queue = { "npe_director", "get_playableQueue"},
            start_timer = 10, --Settings.play_loop,
            functor = { "npe_director", "play_set" }
        },
        play_now_set_queue = {
            name = "play_now_set_queue",
            module = "npe_director",
            group_name = "play",
            exclusive = true,
            execution = npe_execution.TYPE.QUEUE,
            queue = { "npe_director", "get_playableHighPrioQueue"},
            start_timer = 0.1,
            functor = { "npe_director", "play_now_set" }
        },                   
    }    
end

-- runners management

local function add_runners()
    printlog(LOG.ADD, LOG.EXEC," Register runners")
    update_runners_configs()
    for _, runner in pairs(Runner) do
        npe_execution.Add(runner)
    end
end

local function stop_runners()
    printlog(LOG.STOP, LOG.EXEC," Stop runners")
    for _, runner in pairs(Runner) do
        npe_execution.Stop(runner.name)
    end
end

local function stop_execution(runner_name)
    printlog(LOG.STOP, LOG.EXEC," Stop execution: " .. runner_name)
    npe_execution.Stop(runner_name)
end

local function start_runners() -- used as time event
    printlog(LOG.START, LOG.EXEC," Start runners")
    for _, runner in pairs(Runner) do
        npe_execution.Resume(runner.name)
    end
    -- kill the event
    return true
end

local function resume_execution(runner_name)
    printlog(LOG.START, LOG.EXEC," Resume execution: " .. runner_name)
    npe_execution.Resume(runner_name)
end

local function restart_runners()
    printlog(LOG.START, LOG.EXEC," Restart runners")
    stop_runners()
    CreateTimeEvent("NPE_Execution", "Restart", 2, start_runners)
end

local function remove_runners()
    printlog(LOG.REMOVE, LOG.EXEC," Remove runners")
    for _, runner in pairs(Runner) do
        npe_execution.Remove(runner.name)
    end
end


-------------------------------------------------- NPE Execution Functors --------------------------------------------------
-- runners execution functors (functor, queue, stop_condition)

-- contexts countdowns queue consumer
-- update all contexts countdowns in the queue
-- activated contexts (run_npe_context_execution successful) are added to playableOnCountdownQueue if they have a delay
function update_all_npe_contexts_countdowns() -- TODO refactor to a queue with key, value
    printdebug(LOG.RUN, LOG.QUEUE," Update all queued contexts countdowns")
    if playableOnCountdownQueue.setsKeys and #playableOnCountdownQueue.setsKeys > 0 then
        for i, setKey in ipairs(playableOnCountdownQueue.setsKeys) do
            local set, deckId, module = get_set_from_key(setKey)
            if set and set.context.delay and set.context.delay > 0 then
                if not set.context.countdown then
                    printtrace(LOG.INFO, LOG.QUEUE," Play Set [%s] has a delay of %s", set.id, set.context.delay)
                    set.context.countdown = set.context.delay
                elseif set.context.countdown > 0 then
                    printtrace(LOG.INFO, LOG.QUEUE," Play Set [%s] countdown is %s", set.id, set.context.countdown)
                    set.context.countdown = set.context.countdown - 1
                elseif set.context.countdown == 0 then
                    printdebug(LOG.ADD, LOG.QUEUE," Play Set [%s] countdown is over", set.id)
                    table.remove(playableOnCountdownQueue.setsKeys, i)
                    -- if delay countdown is strict, add it to the high prio queue
                    if set.context.strict then
                        table.insert(playableHighPrioQueue.setsKeys, setKey)
                    else
                        table.insert(playableQueue.setsKeys, setKey)
                    end
                end
            end
        end
    end
end

-- contexts execution queue functor
-- functors from npe.Event where their module is MODULE_TYPE.NPE
-- executes the contexts handler functor to see if any context can be activated
-- the functor execution must return true or false
-- sucessful contexts are removed from the queue
-- contexts that fail execution are put back in the queue

function run_npe_context_execution()  -- TODO refactor to a queue with key, value
    printdebug(LOG.RUN, LOG.EXEC," Run Set Context activation functor")
    -- for i, handler in ipairs(npeExecutionQueue.handlers) do
        local handler = table.remove(npeExecutionQueue.handlers, 1)
        if not handler.executed then
            printtrace(LOG.INFO, LOG.EXEC," Running handler [%s]", handler.name)
            local success = true
            for i, functor in ipairs(handler.functors) do
                print_functor(functor)
                success = execute_func(unpack(functor))
                printtrace(LOG.INFO, LOG.EXEC," functor %s executed. Success: %s", functor[1], success)
                if not success then
                    break
                end
            end
            if success then
                printdebug(LOG.ADD, LOG.EXEC," Handler [%s] executed. Success: %s", handler.name, success)
                handler.executed = true
                if AddScriptCallback then
                    printdebug(LOG.ADD, LOG.RGSTR," SendScriptCallback [%s]", handler.callback_name)
                    SendScriptCallback(handler.callback_name)
                    -- table.remove(npeExecutionQueue.handlers, i)
                end
            else
                printdebug(LOG.ERROR, LOG.EXEC," Handler [%s] failed", handler.name)
                -- re-insert the context for the next try
                table.insert(npeExecutionQueue.handlers, handler)
            end
        else
            printdebug(LOG.ERROR, LOG.EXEC," Handler [%s] already executed", handler.name)
        end
    -- end
end

-- play queue consumer
-- the first set in the queue is played
-- if cannot be played because of UI busy, it is put back in the queue
function play_set()
    printdebug(LOG.RUN, LOG.PLAY," Run Play Queued Set")
    if playableQueue.setsKeys and #playableQueue.setsKeys > 0 then
        local setKey = table.remove(playableQueue.setsKeys, 1)
        local set, deckId, module, dialog = get_set_from_key(setKey)
        if set ~= nil then
            set.deckId = deckId
            set.module = module
            if not Dialog_in_use and not actor_menu.inventory_opened() then
                if not set.dialog then
                    set.dialog = dialog
                end
                play_set_dialog(set)
            else
                -- cannot play set, UI is busy. Put it back in the queue
                table.insert(playableQueue.setsKeys, setKey)
            end
        end
    end
end

-- play now queue consumer
-- the first set in the queue is played
-- if cannot be played because of UI busy, it is put back in the queue
function play_now_set()
    printdebug(LOG.RUN, LOG.PLAY," Run Play Now Set")
    if playableHighPrioQueue.setsKeys and #playableHighPrioQueue.setsKeys > 0 then
        local setKey = table.remove(playableHighPrioQueue.setsKeys, 1)
        local set, deckId, module, dialog = get_set_from_key(setKey)    
        if set ~= nil then
            set.deckId = deckId
            set.module = module
            if not Dialog_in_use and not actor_menu.inventory_opened() then
                if not set.dialog then
                    set.dialog = dialog
                end
                play_set_dialog(set)
            else
                -- cannot play set, UI is busy. Put it back in the queue
                table.insert(playableHighPrioQueue.setsKeys, setKey)
            end
        end
    end
end

-- action queue consumer
-- actions are defined in the sets as list of functors from npe_actions
-- if action fails, it is lost undefinitely
-- TODO think about if a retry mechanism is needed
function run_npe_action()
    printdebug(LOG.RUN, LOG.ACTION," Run action")
        local action = table.remove(npeActionsQueue.actions, 1)
        if action then
            printtrace(LOG.INFO, LOG.ACTION," Running action [%s]", action.name)
            local success = execute_func(unpack(action.functor))
            if success then
                printdebug(LOG.INFO, LOG.ACTION," action [%s] executed. Success: %s", action.name, success)
            else
                printdebug(LOG.ERROR, LOG.ACTION," action [%s] failed. Success: %s", action.name, success)
                -- TODO implement retry mechanism?
                -- table.insert(npeActionsQueue.actions, action)
            end
        end
end

-- NPE Activation callbacks  --TODO move this on a runner

function Activate_contexts_on(event)
    printdebug(LOG.RUN, LOG.ACTIV," Activate contexts on [%s]", event.name)
    local setsKeys = find_sets_on(event)
    if setsKeys then
        printdebug(LOG.INFO, LOG.ACTIV," Found sets on [%s]", event.name)
        debug_table(setsKeys)
        add_to_playable_queue(setsKeys)
        -- resume_play_queues_manager_loop()
    end
end

-- NPE Actions  -- TODO move this to a runner
-- TODO needs a dedicated queue to manage the actions delays

function Execute_npe_action(action, setId)
    printdebug(LOG.RUN, LOG.ACTIV," Execute action [%s] on set [%s]", action.descr, setId)
    add_to_actions_queue(action)
    -- resume_execution(Runner.actions_execution_queue.name)
end

-- Execution controls

function Resume_execution_Deprecated() 
    printdebug(LOG.RUN, LOG.EXEC," Resume execution")
    -- npeExecutionQueue.handlers -- this is the queue of the Event handlers
    resume_execution(Runner.contexts_execution_queue.name)
    -- playableQueue.setsKeys -- this is the play set queue
    resume_execution(Runner.play_set_queue.name)
    -- playableHighPrioQueue.setsKeys -- this is play now the queue
    resume_execution(Runner.play_now_set_queue.name)
    
end

function Pause_Execution_Deprecated() 
    printdebug(LOG.STOP, LOG.EXEC," Pause execution")
    -- npeExecutionQueue.handlers -- this is the queue of the Event handlers
    stop_execution(Runner.contexts_execution_queue.name)
    -- playableQueue.setsKeys -- this is the play set queue
    stop_execution(Runner.play_set_queue.name)
    -- playableHighPrioQueue.setsKeys -- this is play now the queue
    stop_execution(Runner.play_now_set_queue.name)

end


-- Activation and Registration

local function activate_oneshot_event(event, callback)
    local f
    f = function() 
    printdebug(LOG.RUN, LOG.ACTIV," Callback for oneshot event ["..event.name .. "] activated")

    printdebug(LOG.REMOVE, LOG.RGSTR," Unregistering callback [" ..callback .. "]")
    UnregisterScriptCallback(callback, f)
    RegisteredCustomCallbacks[callback] = false
    Activate_contexts_on(event)
    end
    return f
end

function Register_npe_callbacks()
    printdebug(LOG.RUN, LOG.RGSTR," Register npe callbacks")
    for setKey, context in pairs(npeSetsActivationQueue.contexts) do
        if context.event.handler.module ~= npe.MODULE_TYPE.NONE then
            if context.event.handler.module == npe.MODULE_TYPE.ANOMALY then
                printdebug(LOG.ADD, LOG.RGSTR," Registering ANOMALY callback [" .. context.event.handler.name .. "] for [".. context.event.name .. "]")
                RegisterScriptCallback(context.event.handler.name,activate_oneshot_event(context.event, context.event.handler.name))    
            else
                -- here I should enable the CUSTOM handlers (execute on actor_update) and the callbacks that will react to them
                if AddScriptCallback then
                    local callback_name = context.event.handler.module .. "_" .. context.event.handler.name
                    context.event.handler.callback_name = callback_name
                    if not RegisteredCustomCallbacks[callback_name] then
                        RegisteredCustomCallbacks[callback_name] = true
                        add_to_execution_queue(context.event.handler)
                        AddScriptCallback(callback_name)
                        printdebug(LOG.ADD, LOG.RGSTR," Registering CUSTOM callback [" .. callback_name .. "] for [".. context.event.name .. "]")
                        RegisterScriptCallback(callback_name,activate_oneshot_event(context.event, callback_name))                        
                    end
                end
            end
        end
    end
end

local function update_settings()
    -- NPE FLAGS
    Dialog_in_use = false
    Dialog_name = nil
    -- NPE General Settings
    Settings.enable = npe_mcm.npe_get_setting("general", "enable")
    Settings.execution_loop = npe_mcm.npe_get_setting("general", "execution_loop")
    Settings.play_loop = npe_mcm.npe_get_setting("general", "play_loop")  
    Settings.sounds_set = npe_mcm.npe_get_setting("general", "sounds_set")  
    Settings.pause_game = npe_mcm.npe_get_setting("general", "pause_game")  
    printf(" Settings:")

    local function m_print_table(t, indent)
        if not t then
            return
        end
        indent = indent or ''
        for key, value in pairs(t) do
            if type(value) == 'table' then
                printf(indent .. '' .. key .. ':')
                m_print_table(value, indent .. '  ')
            else
                printf(indent .. key .. ': ' .. tostring(value))
            end
        end
    end    
    m_print_table(Settings)

end

local function first_time_initialization()
    printlog(LOG.RUN, LOG.CONF," First time initialization")
    -- npe Settings
    update_settings()
    
   -- update the npeConfig table with the Settings from the MCM
   update_decks_from_mcm()
   apply_overrides_to_decks()
   -- Use the function to print the npeConfig.decks table
   printlog(LOG.RUN, LOG.CONF," Listing Decks")
   print_table(npeConfig.decks)
   printlog(LOG.RUN, LOG.CONF," Decks list Ended")

   -- update the queue with the contexts from the npeConfig table
   update_activation_queue()

    -- register the queued contexts with the npe_events
   Register_npe_callbacks()
   
   -- Use the function to print the npeSetsActivationQueue table
   printlog(LOG.RUN, LOG.CONF," Activation Queue:")
   print_table(npeSetsActivationQueue.contexts)
   printlog(LOG.RUN, LOG.CONF," Activation Queue list Ended")

end

local function init_npe_execution()
    printlog(LOG.RUN, LOG.EXEC," Init NPE Execution")
    add_runners()
    start_runners()
end


local function start_npe() -- timed event
    printlog(LOG.RUN, LOG.EXEC," Start NPE")
 
    -- activate the contexts on EVENT.GAME_START
    Activate_contexts_on(npe.EVENT.GAME_START)
    Activate_contexts_on(npe.EVENT.DLC_START)

    -- kill the event
    return true
end

local function npe_on_log_init()
    printlog(LOG.RUN, LOG.EXEC," Actor on first update")

    -- initialize npe configuration
    first_time_initialization()

    -- delay the start of the NPE
    CreateTimeEvent("NPE_App", "Start", 3, start_npe)    
end

local function mcm_on_option_change()
    printdebug(LOG.RUN, LOG.EXEC," On option change")
    -- pausing all loops
    Pause_Execution_Deprecated() 

    -- update npe configuration
    update_settings()

    update_decks_from_mcm()
    

    -- Use the function to print the npeConfig.decks table
    printdebug(LOG.RUN, LOG.CONF," Listing Decks:")
    debug_table(npeConfig.decks)
    printdebug(LOG.RUN, LOG.CONF," Decks list Ended")

    -- upcate the queue with the contexts from the npeConfig table
    update_activation_queue()

    -- Use the function to print the npeSetsActivationQueue table
    printdebug(LOG.RUN, LOG.CONF," Activation Queue:")
    debug_table(npeSetsActivationQueue.contexts)
    printdebug(LOG.RUN, LOG.CONF," Activation Queue list Ended")
    -- register the queued contexts with the npe_events
    Register_npe_callbacks()

    -- resume all loops
    Resume_execution_Deprecated()

    -- runners
    update_runners_configs()
    restart_runners()
end

local function teardown_npe()
    printlog(LOG.RUN, LOG.EXEC," Teardown")
	if Dialog_in_use then
        tear_down_dialog()
	end

    remove_runners()
end

function on_game_start()
    -- the app will start after the logging system is initialized
    RegisterScriptCallback("npe_on_log_init", npe_on_log_init)
    
    RegisterScriptCallback("on_option_change", mcm_on_option_change)
    RegisterScriptCallback("actor_on_net_destroy", teardown_npe)
    RegisterScriptCallback("actor_on_before_death",teardown_npe)
    RegisterScriptCallback("npe_execution_manager_started",init_npe_execution)
end