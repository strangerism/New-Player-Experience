
local printlog = npe_manager.Printlog_npe
local printdebug = npe_manager.Printdebug_npe

-- monkey patching radio stuff from item_radio.script

RADIO_TYPE = {
    VANILLA = "VANILLA",
    NERFS = "NERFS",
    DAR = "DAR"
}

NERFS_RADIO = "<NERFS> "
NERFS_VANILLA = "1.6-b2"
NERFS_DAR = "1.5-DAR"

-- saving radio sounds for restoration

local no_sound = sound_object("radio\\no_sound")
local snd_emission = {}
local snd_emission_restore = nil
local snd_random = {}
local snd_random_restore = nil
local snd_talk = {}
local snd_talk_restore = nil

local snd_on_restore = nil
local snd_off_restore = nil
local snd_noise_restore = nil
local snd_white_noise_restore = nil


function Get_radio_type()
    if item_radio.logprefix and item_radio.logprefix == NERFS_RADIO then
        if item_radio.script_version == NERFS_VANILLA then
            return RADIO_TYPE.NERFS
        elseif dar_rf_noise then
            return RADIO_TYPE.DAR
        else
            return RADIO_TYPE.NERFS
        end
    else
        return RADIO_TYPE.VANILLA
    end
end

local function configure_radio_sounds_for_restoration()
    if Get_radio_type() == RADIO_TYPE.VANILLA then
        -- creating silent sounds library
        snd_emission_restore = item_radio.snd_emission
        for i=1,8 do snd_emission[i] = no_sound end
        snd_random_restore = item_radio.snd_random
        for i=1,13 do snd_random[i] = no_sound end
        snd_talk_restore = item_radio.snd_talk
        for i=1,33 do snd_talk[i] = no_sound end
    
        snd_on_restore = item_radio.snd_on
        snd_off_restore = item_radio.snd_off
        snd_noise_restore = item_radio.snd_noise
        snd_white_noise_restore = item_radio.snd_noise
        snd_emission_restore = item_radio.snd_emission
        snd_random_restore = item_radio.snd_random
        snd_talk_restore = item_radio.snd_talk    
    else
        -- creating silent sounds library
        snd_noise_restore = item_radio.get_signal_sound("noise")
        snd_white_noise_restore = item_radio.get_signal_sound("white_noise")
        
    end
end


local function silence_nerf_radio(silence)
    item_radio.disable_all_sounds = silence
    if silence then
        item_radio.set_signal_sound("noise", "$no_sound")
        item_radio.set_signal_sound("white_noise", "$no_sound")
    else
        item_radio.set_signal_sound("noise", snd_noise_restore)
        item_radio.set_signal_sound("white_noise", snd_white_noise_restore)
    end
end

local function silence_vanilla_radio(silence)
    if silence then
        item_radio.snd_noise = no_sound
        item_radio.snd_white_noise = no_sound
        item_radio.snd_on = no_sound
        item_radio.snd_off = no_sound
        item_radio.snd_emission = snd_emission     
        item_radio.snd_random = snd_random
        item_radio.snd_talk = snd_talk  
    else
        item_radio.snd_noise = snd_noise_restore
        item_radio.snd_white_noise = snd_white_noise_restore
        item_radio.snd_on = snd_on_restore
        item_radio.snd_off = snd_off_restore
        item_radio.snd_emission = snd_emission_restore     
        item_radio.snd_random = snd_random_restore
        item_radio.snd_talk = snd_talk_restore                                         
    end
end

-- updates radio sounds
function Mute_radio(silence)
    printdebug("[NPE][ACTIONS] Mute radio " .. Get_radio_type() .. " ("..tostring(silence)..")")
    if Get_radio_type() == RADIO_TYPE.VANILLA then
        silence_vanilla_radio(silence)
    else
        silence_nerf_radio(silence)        
    end
    -- returns true to prevent further execution of the function (e.g. from timed events)
    return true
end

function set_radio_freq(new_frequency)
    printdebug("[NPE][ACTIONS] set_radio_freq("..new_frequency..")")

	local oldf = math.floor(item_radio.get_freq())
    printdebug("[NPE][ACTIONS] oldf = "..oldf)
    local increment = 0
    if oldf >= new_frequency then
        increment = oldf - new_frequency
    else
        increment = new_frequency - oldf
    end
    printdebug("[NPE][ACTIONS] increment = "..increment)
    if increment == 0 then
        return
    end
	item_radio.change_freq(increment)
end

-- functions lifted from Haru's Detector Selector mod script detector_selector_mcm
-- credits to Haru for the original code

Devices = {
    anomaly = {
        devices = {
			["detector_grizzly_up"] = 10,
            ["detector_scientific_up"] = 9,
            ["detector_elite_up"] = 8,
            ["detector_advanced_up"] = 7,
            ["detector_simple_up"] = 6,
			["detector_grizzly"] = 5,
            ["detector_scientific"] = 4,
            ["detector_elite"] = 3,
            ["detector_advanced"] = 2,
            ["detector_simple"] = 1
        }
    },
    radio = {
        devices = {
            ["detector_radio"] = 1
        },
    },
    geiger = {
        devices = {
            ["detector_geiger"] = 1
        },
    },
    lights = {
        devices = {
            ["device_flashlight"] = 1
        },
    },
    detector_anomaly = {
        devices = {
            ["detector_anomaly"] = 1
        },
    }
}
local callback_name_on_equip = nil
function set_callback_on_equip(callback_name)
    callback_name_on_equip = callback_name
end
function timed_callback_notification()
    if callback_name_on_equip then
        SendScriptCallback(callback_name_on_equip)
    end

    return true
end
function show_event()
    db.actor:show_detector(true)
    CreateTimeEvent("haru_timed_callback_notification", "haru_timed_callback_notification", 0.3, timed_callback_notification)
    return true
end

function set_detector_open_sound(sound)
    if sound then
        if Get_radio_type() == RADIO_TYPE.VANILLA then
            item_radio.snd_on = sound_object(sound)
        end
    end
end

function set_detector_close_sound(sound)
    if sound then
        if Get_radio_type() == RADIO_TYPE.VANILLA then
            item_radio.snd_off = sound_object(sound)
        end
    end
end

function hide_detector(obj)
    obj:switch_state(2)
    local det_hide_time = (obj:play_hud_motion("anm_hide_fast", true, 3, 2, 0) / 1000) + 0.25
    CreateTimeEvent("haru_hide_detector", "haru_hide_detector", det_hide_time, hide_event, obj)
end

function Unequip_detector()
    printdebug("[NPE][ACTIONS] Unequip_detector()")
    local actor = db.actor
    local device_in_slot = actor:item_in_slot(9)
    if device_in_slot then
        hide_detector(device_in_slot)
    end
end

function hide_event(obj)
    db.actor:force_hide_detector()
    obj:switch_state(3)
    return true
end

function cycle_detector(prev, next)
    prev:switch_state(2)
    local det_hide_time = (prev:play_hud_motion("anm_hide_fast", true, 3, 2, 0) / 1000) + 0.25
    CreateTimeEvent("haru_hide_detector", "haru_hide_detector", det_hide_time, function(prev, next)
        hide_event(prev)
        db.actor:move_to_slot(next, 9)
        CreateTimeEvent("haru_show_detector","haru_show_detector", 0.1, show_event)
        return true
    end, prev, next)
end

function select_detector(category)
    local devices = category.devices
    local actor = db.actor
    local device_in_slot = actor:item_in_slot(9)
    local active_device = actor:active_detector()
    if device_in_slot and devices[device_in_slot:section()] then
        CreateTimeEvent("haru_show_detector","haru_show_detector", 0.1, show_event)
        return
    end
    local devices_ruck = {}
    actor:iterate_inventory(function(owner, obj)
        local sec = obj and obj:section()
        if sec and devices[sec] then
            devices_ruck[#devices_ruck + 1] = {
                ["object"] = obj, 
                ["weight"] = devices[sec] + obj:condition()
            }
        end
    end, actor)
    if is_empty(devices_ruck) then
        return
    end
    table.sort(devices_ruck, function(a,b) return a.weight > b.weight end)
    if active_device then
        cycle_detector(active_device, devices_ruck[1].object)
        return
    end
    actor:move_to_slot(devices_ruck[1].object, 9)
    CreateTimeEvent("haru_show_detector","haru_show_detector", 0.1, show_event)
end

-- end of Haru's Detector Selector mod script detector_selector_mcm

-- USABLE ACTIONS

EFFECTOR = {
    BLUR = {name ="blur.ppe", c_id = 5606},
    BLACK_INFINITE = {name = "black_infinite.ppe", c_id = 5600},
    AUDIO_SHOCK = {name = "snd_shock.ppe", c_id = 5607},
    RADIATION = {name = "radiation.ppe", c_id = 5608},
    ALCOHOL = {name = "alcohol.ppe", c_id = 5609},
}

function remove_all_psy_ppe_effects()
    printdebug("[NPE][ACTIONS] remove_all_psy_ppe_effects")
    level.remove_pp_effector(EFFECTOR.BLUR.c_id)
    -- level.remove_pp_effector(EFFECTOR.BLACK_INFINITE.name)
    level.remove_pp_effector(EFFECTOR.AUDIO_SHOCK.c_id)
    level.remove_pp_effector(EFFECTOR.RADIATION.c_id)
    level.remove_pp_effector(EFFECTOR.ALCOHOL.c_id)
    return true
end

function set_all_psy_ppe_effects(duration, set_id)
    printdebug("[NPE][ACTIONS] set_all_psy_ppe_effects with duration = " .. duration .. " for set_id = " .. set_id)
    level.add_pp_effector(EFFECTOR.BLUR.name, EFFECTOR.BLUR.c_id, true)
    -- level.add_pp_effector(EFFECTOR.BLACK_INFINITE.name, EFFECTOR.BLACK_INFINITE.c_id, true)
    level.add_pp_effector(EFFECTOR.AUDIO_SHOCK.name, EFFECTOR.AUDIO_SHOCK.c_id, true)
    level.add_pp_effector(EFFECTOR.RADIATION.name, EFFECTOR.RADIATION.c_id, true)
    level.add_pp_effector(EFFECTOR.ALCOHOL.name, EFFECTOR.ALCOHOL.c_id, true)
    CreateTimeEvent("npe_remove_all_psy_ppe_effects", "npe_remove_all_psy_ppe_effects" .. set_id, duration, remove_all_psy_ppe_effects)
    return true
end

function npe_remove_effector(effector)
    printdebug("[NPE][ACTIONS] npe_remove_effector("..effector.name..")")
    level.remove_pp_effector(effector.c_id)
    return true
end

function npe_remove_effectors(effectors_table)
    printdebug("[NPE][ACTIONS] npe_remove_effectors")
    for i, effector in ipairs(effectors_table) do
        npe_remove_effector(effector)
    end
    return true
end

function npe_add_effector(effector, duration, set_id)
    printdebug("[NPE][ACTIONS] npe_add_effector("..effector.name..", "..duration..", "..set_id..")")
    level.add_pp_effector(effector.name. effector.c_id, true)
    if duration then
        CreateTimeEvent("npe_remove_effector", "npe_remove_effector" .. set_id, duration, npe_remove_effector, effector)
    end
    return true
end

function npe_add_effectors(effectors_table, duration, set_id)
    printdebug("[NPE][ACTIONS] npe_add_effectors")
    for i, effector in ipairs(effectors_table) do
        npe_add_effector(effector, duration, set_id)
    end
    return true
end

function add_to_actor(money, items)
    printdebug("[NPE][ACTIONS] add_to_actor("..money..", items)")
    local reward = {
        [1] = { reward_money = money, reward_item = items}
    }
    
    xr_effects.give_reward(db.actor,nil,reward)
    return true
end

function remove_from_actor(items)
    printdebug("[NPE][ACTIONS] remove_from_actor(items)")
    xr_effects.remove_item(db.actor, nil, items)
    return true
end

function add_to_stash(items, stash_id)
    printdebug("[NPE][ACTIONS] add_to_stash(items, "..stash_id..")")
    local stash_obj = alife_object(stash_id) 
    if not stash_obj then
        printdebug("[NPE][ACTIONS] stash does not exists")
        return true
    end
	for i=1,#items do
		local section = items[i]
        local se_itm = alife_create_item(section, stash_obj, nil)
    end
    return true
end

-- function spawn_lootbox(items, box)
--     local id = box:id()

--     local se_obj = alife_object(id) 
--     if not se_obj then
--         printdebug("[NPE][ACTIONS] stash does not exists")
--         return
--     end

--     local lvl = alife():level_name(game_graph():vertex(se_obj.m_game_vertex_id):level_id())
--     printdebug("[NPE][ACTIONS] spawn_lootbox() level = " .. lvl)
-- 	for i=1,#spawned_item do
-- 		local section = spawned_item[i]
--         local se_itm = alife_create_item(section, box, nil)
--     end

--     -- local se_obj = alife_create(section,box:position(),box:level_vertex_id(),box:game_vertex_id(),box:id(),false)
--     -- alife():register(se_obj)    



-- end




function actor_on_item_put_in_box(box, itm)
	printdebug("[NPE][ACTIONS] box_id = " .. box:id())
end

function on_game_start()
    printlog("[NPE][ACTIONS] on_game_start()")
    configure_radio_sounds_for_restoration()
    -- RegisterScriptCallback("actor_on_item_put_in_box",actor_on_item_put_in_box)
end