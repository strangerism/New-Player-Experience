-- NPE Data Structures

local npeConfig = {
    decks = {},
}

local npeSetsActivationQueue = {
    contexts = {},
}

local playableQueue = {
    setsKeys = {},
}

local playableHighPrioQueue = {
    setsKeys = {},
}

local playableOnCountdownQueue = {
    setsKeys = {},
}
local npeExecutionQueue = {
    handlers = {},
}

local npeActionsQueue = {
    actions = {},
}

Settings = {
    enable = true,
    execution_loop = 3,
    actions_execution_loop = 1,
    play_loop = 10,
    sounds_set = "NPE",
    pause_game = false,
    debug_logs = true,
    conf_logs = false,
    overr_logs = false,
    rgstr_logs = false,
    pool_logs = false,
    exec_logs = false,
    activ_logs = false,
    queue_logs = false,
    play_logs = false,
    event_logs = false,
    action_logs = false,
    ui_logs = false,
    ui_exec_logs = false,
}

LOG = {
    -- NPE tag
    NPE = { tag = "[NPE]"},
    -- log types
    INFO = { tag = ""},
    START = { tag = "-"},
    STOP = { tag = "!"},
    ERROR = { tag = "!"},
    ADD = { tag = "-"},
    REMOVE = { tag = "!"},
    RUN = { tag = "//"},
    -- categories
    CONF = { tag = "[CONF]", enabled = Settings.conf_logs},
    OVERR = { tag = "[OVERR]", enabled = Settings.overr_logs},
    RGSTR = { tag = "[RGSTR]", enabled = Settings.rgstr_logs},
    POOL = { tag = "[POOL]", enabled = Settings.pool_logs},
    EXEC = { tag = "[EXEC]", enabled = Settings.exec_logs},
    ACTIV = { tag = "[ACTIV]", enabled = Settings.activ_logs},
    QUEUE = { tag = "[QUEUE]", enabled = Settings.queue_logs},
    PLAY = { tag = "[PLAY]", enabled = Settings.play_logs},
    EVENT = { tag = "[EVENT]", enabled = Settings.event_logs},
    ACTION = { tag = "[ACTION]", enabled = Settings.action_logs},
    UI = { tag = "[UI]", enabled = Settings.ui_logs},
    UI_EXEC = { tag = "[UI_EXEC]", enabled = Settings.ui_exec_logs},
}

RegisteredCustomCallbacks = {}

-- NPE FLAGS
Dialog_in_use = false
Dialog_name = nil

-- NPE Utils

local function printlog(type,category,msg,...)
	msg = msg or " "
    if not category.enabled then return end
    if type then
        msg = type.tag .. LOG.NPE.tag .. category.tag  .. msg
    else
        msg = LOG.NPE.tag .. category.tag  .. msg
    end
	if select('#', ...) ~= 0 then printf(string.format(msg,...))
	else printf(msg)
	end
end

local function printdebug(type,category, msg,...) -- debug logging
	if Settings.debug_logs then printlog(type,category, msg,...) end
end
Printlog_npe = printlog
Printdebug_npe = printdebug

local function print_table(t, indent)
    if not t then
        return
    end
    indent = indent or ''
    for key, value in pairs(t) do
        if type(value) == 'table' then
            printlog(LOG.INFO, LOG.CONF, indent .. '' .. key .. ':')
            print_table(value, indent .. '  ')
        else
            printlog(LOG.INFO, LOG.CONF, indent .. key .. ': ' .. tostring(value))
        end
    end
end
Print_table_npe = print_table

local function debug_table(t, indent)
    if not t then
        return
    end
    indent = indent or ''
    for key, value in pairs(t) do
        if type(value) == 'table' then
            printdebug(LOG.INFO, LOG.CONF,indent .. '' .. key .. ':')
            debug_table(value, indent .. '  ')
        else
            printdebug(LOG.INFO, LOG.CONF,indent .. key .. ': ' .. tostring(value))
        end
    end
end
Debug_table_npe = debug_table

-- NPE hashing functions

local function map_to_set_key(deckId, setId)
    return deckId .. "/" .. setId
end

local function map_from_set_key(key)
    local split = string.gmatch(key, "[^/]+")
    local deckId = split()
    local setId = split()
    return deckId, setId
end

local function get_set_from_key(key)
    local deckId, setId = map_from_set_key(key)
    local deck = npeConfig.decks[deckId]
    if deck ~= nil then
        return deck.sets[setId], deckId, deck.module, deck.dialog
    end
    return nil
end

-- NPE Modules registration

local function add_deck(npeDeck)
    if npeDeck ~= nil then
        if npeConfig.decks[npeDeck.id] == nil then
            local indexedSets = {}
            for _, set in pairs(npeDeck.sets) do
                if not set.disabled then
                indexedSets[set.id] = set
                end
            end
            npeDeck.sets = indexedSets
            npeConfig.decks[npeDeck.id] = npeDeck
        else
            printlog(LOG.ERROR, LOG.CONF,"Deck with id [" .. npeDeck.id .. "] already exists.")
        end
    end
end

function Register_npe_module(deck)

    printlog(LOG.ADD, LOG.RGSTR,"[".. deck.id .. "] Adding deck " .. deck.title .. " to NPE Manager.")
    add_deck(deck)
end

-- NPE decks update from MCM

local function update_decks_from_mcm()
    printlog(LOG.ADD, LOG.CONF," Update decks from MCM")
    for deckId, deck in pairs(npeConfig.decks) do
        for setId, set in pairs(deck.sets) do
            set.played = npe_mcm.npe_module_get_setting(deck.module, set.id)
            -- reset the overridden flag
            if set.overridden then
                set.overridden = false
            end
            if set.context.event.handler.executed then
                set.context.event.handler.executed = false
            end
            if set.context.countdown then
                set.context.countdown = nil
            end
        end
    end
end

local function override_cards(set, setToOverride)
    for cardKey, card in pairs(set.cards) do
        if setToOverride.cards[cardKey] ~= nil then
            for fieldKey, fieldValue in pairs(card) do
                if fieldValue ~= nil then
                    printlog(LOG.INFO, LOG.OVERR," Override card [%s] field [%s] with value [%s]", cardKey, fieldKey, fieldValue)
                    setToOverride.cards[cardKey][fieldKey] = fieldValue
                end
            end
        end
    end
    return setToOverride
end

local function override_contexts(context, setToOverride)
    for contextKey, contextValue in pairs(context) do
        if contextKey ~= "override" and contextValue ~= nil then
            printdebug(LOG.INFO, LOG.OVERR," Override context [%s] with value [%s]", contextKey, contextValue)
            setToOverride.context[contextKey] = contextValue
        end
    end
    return setToOverride
end

local function apply_overrides_to_decks()
    printdebug(LOG.RUN, LOG.OVERR," Apply overrides to decks")
    for deckId, deck in pairs(npeConfig.decks) do
        printdebug(LOG.RUN, LOG.OVERR," Searching into Deck [%s]:", deckId)
        for setId, set in pairs(deck.sets) do
            printdebug(LOG.RUN, LOG.OVERR," Searching into Set [%s]:", setId)
            if set.context and set.context.override and not set.played then
                printdebug(LOG.RUN, LOG.OVERR," Set [%s] has override rules:", setId)
                debug_table(set.context.event.override)
                local overrideDeckId = set.context.override.deckId
                local overrideSetId = set.context.override.setId
                if npeConfig.decks[overrideDeckId] and npeConfig.decks[overrideDeckId].sets[overrideSetId] then
                    local setToOverride = npeConfig.decks[overrideDeckId].sets[overrideSetId]
                    printdebug(LOG.RUN, LOG.OVERR," Override set [%s] data with content from set [%s]", setToOverride.id, set.id)
                    setToOverride = override_cards(set, setToOverride)
                    if set.title then
                        setToOverride.title = set.title
                        printdebug(LOG.RUN, LOG.OVERR," Override set [%s] title with [%s]", setToOverride.id, set.title)
                    end
                    if set.context.override.replay then
                        setToOverride.played = false
                        printdebug(LOG.RUN, LOG.OVERR," Override set [%s] played flag with false", setToOverride.id)
                    end
                    setToOverride = override_contexts(set.context, setToOverride)
                    -- set the overridden flag to this set is not added to the activation queue
                    set.overridden = true
                    -- upodate the npeConfig.decks table with the new changes
                    npeConfig.decks[deckId].sets[setId] = set
                    npeConfig.decks[overrideDeckId].sets[overrideSetId] = setToOverride                    
                else
                    printlog("![NPE][OVERR] Deck with id [%s] or Set with id [%s] to for overriding, does not exist.", overrideDeckId, overrideSetId)
                end
            end
        end
    end
end

-- NPE Queues

local function compare_events(event1, event2)
    if event1.name ~= event2.name then
        return false
    end
    if event1.module ~= event2.module then
        return false
    end
    return true
end

local function find_sets_on(event)
    printdebug(LOG.INFO, LOG.ACTIV," Find sets activating on event [%s]", event.name)
    local setsKeys = {}
    for setKey, queued_context in pairs(npeSetsActivationQueue.contexts) do
        if compare_events(queued_context.event, event) then
            printdebug(LOG.INFO, LOG.ACTIV," queued context [%s]", setKey)
            table.insert(setsKeys, setKey)
        end
    end
    return setsKeys
end

local function add_to_sets_queue(set, deckId, module)
    -- printdebug(LOG.INFO, LOG.QUEUE," Add sets to activation queue: [%s] [%s]", deckId, set.id)
    local setKey = map_to_set_key(deckId, set.id)
    -- printdebug(LOG.INFO, LOG.QUEUE," setKey [%s]", setKey)
    if set ~= nil then
        -- do not queue a set that was used to override another set
        if set.overridden then return end
        -- Create a context table with the event and delay from the set
        local context = {
            event = set.context.event,
            delay = set.context.delay,
            pause_game = set.context.pause_game,
        }
        if not context.event.handler.module then
            context.event.handler.module = module
        end
        -- Check if a context with the same contextId already exists
            if npeSetsActivationQueue.contexts[setKey] == nil then
                -- Add the new context to the table with contextId as the key
                npeSetsActivationQueue.contexts[setKey] = context
            printdebug(LOG.INFO, LOG.QUEUE," context with id [" .. setKey .. "] added to the queue with event [" .. context.event.name .. "] and module [" .. context.event.handler.module .. "]")
            else 
            -- TODO we should use here THE context.override directive to replace the contexts
                printlog(LOG.ERROR, LOG.QUEUE," context with id [" .. setKey .. "] already exists.")
            printlog(LOG.ERROR, LOG.QUEUE," context event [" .. context.event.name .. "] and module [" .. context.event.handler.module .. "]")
            end
    end
end

local function add_to_playable_queue(setsKeys)
    if setsKeys == nil then
        return
    end
    for i, setKey in ipairs(setsKeys) do
        -- add set to the playable queue
        local set, deckId, module = get_set_from_key(setKey)
        if set then
            if set.context.delay then 
                if set.context.delay == 0 then
                    printdebug(LOG.INFO, LOG.QUEUE," Set [%s] plays instantly - Set added to the play_now queue", setKey)
                    table.insert(playableHighPrioQueue.setsKeys, setKey)                
                else 
                    printdebug(LOG.INFO, LOG.QUEUE," Set [%s] has a delay of [%s] - Set added to the countdown queue", setKey, set.context.delay)
                    table.insert(playableOnCountdownQueue.setsKeys, setKey)
                end
            else
                printdebug(LOG.INFO, LOG.QUEUE," Set [%s] plays with default play_loop - Set added to the play queue", setKey)
                table.insert(playableQueue.setsKeys, setKey)
            end
            -- removes it from the npeSetsActivationQueue
            npeSetsActivationQueue.contexts[setKey] = nil            
        end
    end
end

local function add_to_execution_queue(handler)
    if handler == nil then
        return
    end
    table.insert(npeExecutionQueue.handlers, handler)
end

local function add_to_actions_queue(action)
    if action == nil then
        return
    end
    table.insert(npeActionsQueue.actions, action)
end

local function update_activation_queue()
    printdebug(LOG.RUN, LOG.QUEUE," Update activation queue")
    npeSetsActivationQueue = {
        contexts = {},
    }
    for deckId, deck in pairs(npeConfig.decks) do
        for setId, set in pairs(deck.sets) do
            -- Only call add_to_sets_queue if set.played is false
            if set.played == false then
                add_to_sets_queue(set, deck.id, deck.module)
            end
        end
    end
end

local function update_queued_contexts_countdowns()
    if playableOnCountdownQueue.setsKeys and #playableOnCountdownQueue.setsKeys > 0 then
        for i, setKey in ipairs(playableOnCountdownQueue.setsKeys) do
            local set, deckId, module = get_set_from_key(setKey)
            if set and set.context.delay and set.context.delay > 0 then
                if not set.context.countdown then
                    printdebug(LOG.INFO, LOG.QUEUE," Play Set [%s] has a delay of %s", set.id, set.context.delay)
                    set.context.countdown = set.context.delay
                elseif set.context.countdown > 0 then
                    printdebug(LOG.INFO, LOG.QUEUE," Context [%s] countdown is %s", set.context.event.name, set.context.countdown)
                    set.context.countdown = set.context.countdown - 1
                elseif set.context.countdown == 0 then
                    printdebug(LOG.INFO, LOG.QUEUE," Context [%s] countdown is over", set.context.event.name)
                    table.insert(playableHighPrioQueue.setsKeys, setKey)
                    table.remove(playableOnCountdownQueue.setsKeys, i)
                end
            end
        end
    end
end

-- NPE Activation and Execution

local function print_functor(functor)
    for i, v in ipairs(functor) do
        if type(v) == "table" then
            printdebug(LOG.INFO, LOG.EXEC,"Table at index " .. i .. ":")
            print_functor(v)
        else
            printdebug(LOG.INFO, LOG.EXEC,"Element at index " .. i .. ": " .. v)
        end
    end
end
local function run_execution_queue()
    printdebug(LOG.RUN, LOG.EXEC," Run execution queue")
    for i, handler in ipairs(npeExecutionQueue.handlers) do
        if not handler.executed then
            printdebug(LOG.INFO, LOG.EXEC," Running handler [%s]", handler.name)
            print_functor(handler.functor)
            local success = execute_func(unpack(handler.functor))   
            if success then
                printdebug(LOG.INFO, LOG.EXEC," Handler [%s] executed. Success: %s", handler.name, success)
                handler.executed = true
                if AddScriptCallback then
                    printdebug(LOG.ADD, LOG.RGSTR," SendScriptCallback [%s]", handler.callback_name)
                    SendScriptCallback(handler.callback_name)
                    table.remove(npeExecutionQueue.handlers, i)
                end
            end
        end
    end
end

-- NPE Play sets

local function start_dialog(set)
    -- if dialog is null, use the default dialog
    if not set.dialog then
        set.dialog = npe.DIALOG.UI_TUTORIAL
    end
    printlog(LOG.INFO, LOG.PLAY," Starting dialog [%s]",set.dialog )
    local dialog_functor = {set.dialog, "Play", set}
    execute_func(unpack(dialog_functor))
end

local function tear_down_dialog()
    local dialog_functor = {Dialog_name .. "_dialog", "TearDown"}
    execute_func(unpack(dialog_functor))
end

-- used by the dialog to register back to the NPE
function Register_dialog(dialog)
    Dialog_name = dialog
    Dialog_in_use = true
end
function Unregister_dialog()
    Dialog_name = nil
    Dialog_in_use = false
end

local function play_set(set)
    printdebug(LOG.INFO, LOG.PLAY," Playing set [%s] from module [%s]", set.id, set.module)
    printdebug(LOG.INFO, LOG.PLAY," Set Title: [%s]", set.title)

    set.played = true
    npe_mcm.npe_module_set_setting(set.module, set.id, true)
    
    Pause_Execution()

    start_dialog(set)
end

local function play_queued_set()
    if playableQueue.setsKeys and #playableQueue.setsKeys > 0 then
        local setKey = table.remove(playableQueue.setsKeys, 1)
        local set, deckId, module, dialog = get_set_from_key(setKey)
        if set ~= nil then
            set.deckId = deckId
            set.module = module
            if not Dialog_in_use then
                if not set.dialog then
                    set.dialog = dialog
                end
                play_set(set)
            else
                -- cannot play set, UI is busy. Put it back in the queue
                table.insert(playableQueue.setsKeys, setKey)
            end
        end
    end
end

local function play_now_set()
    if playableHighPrioQueue.setsKeys and #playableHighPrioQueue.setsKeys > 0 then
        local setKey = table.remove(playableHighPrioQueue.setsKeys, 1)
        local set, deckId, module, dialog = get_set_from_key(setKey)    
        if set ~= nil then
            set.deckId = deckId
            set.module = module
            if not Dialog_in_use then
                if not set.dialog then
                    set.dialog = dialog
                end
                play_set(set)
            else
                -- cannot play set, UI is busy. Put it back in the queue
                table.insert(playableHighPrioQueue.setsKeys, setKey)
            end
        end
    end
end

---- NPE Execution ----

-- Execution loop - this will always run
local run_execution_loop = false
local run_execution_loop_name = 'NPE_Execution_Loop'

local function npe_execution_loop()
    printdebug(LOG.RUN, LOG.POOL," Contexts Activation execution loop")
    if not run_execution_loop then return true end
    ResetTimeEvent(run_execution_loop_name, run_execution_loop_name, Settings.execution_loop)

    run_execution_queue()

    return false
end
local function pause_execution_loop()
    printdebug(LOG.RUN, LOG.EXEC," pausing contexts execution loop")
    if not run_execution_loop then return end
    run_execution_loop = false
    printdebug(LOG.STOP, LOG.EXEC," paused contexts execution loop")
end

local function resume_execution_loop()
    printdebug(LOG.RUN, LOG.EXEC," resuming contexts execution loop")
    if run_execution_loop then return end
    run_execution_loop = true
    CreateTimeEvent(run_execution_loop_name, run_execution_loop_name, Settings.execution_loop, npe_execution_loop)
    printdebug(LOG.START, LOG.EXEC," resumed contexts execution loop")
end

local function remove_execution_loop()
    printdebug(LOG.STOP, LOG.EXEC," removing contexts execution loop")
    RemoveTimeEvent(run_execution_loop_name, run_execution_loop_name)
end

-- Actions Execution loop
local run_actions_execution_loop = false
local run_actions_execution_loop_name = 'NPE_actions_execution_loop'

local function pause_actions_execution_loop()
    printdebug(LOG.RUN, LOG.EXEC," pausing actions execution loop")
    if not run_actions_execution_loop then return end
    run_actions_execution_loop = false
    printdebug(LOG.STOP, LOG.EXEC," paused actions execution loop")
end

local function run_actions_execution_queue()
    printdebug(LOG.RUN, LOG.EXEC," Run actions execution queue")
    if #npeActionsQueue.actions == 0 then pause_actions_execution_loop() end
    for i, action in ipairs(npeActionsQueue.actions) do
            printdebug(LOG.INFO, LOG.EXEC," Running action [%s]", action.name)
            local success = execute_func(unpack(action.functor))
            table.remove(npeActionsQueue.actions, i)
            if success then
                printdebug(LOG.INFO, LOG.EXEC," action [%s] executed. Success: %s", action.name, success)
            end
    end
end

local function npe_actions_execution_loop()
    printdebug(LOG.RUN, LOG.POOL," Actions Execution loop")
    if not run_actions_execution_loop then return true end
    ResetTimeEvent(run_actions_execution_loop_name, run_actions_execution_loop_name, Settings.actions_execution_loop)
    printdebug(LOG.RUN, LOG.EXEC," running actions execution queue")
    run_actions_execution_queue()

    return false
end
local function resume_actions_execution_loop()
    printdebug(LOG.RUN, LOG.EXEC," resuming contexts activation loop")
    if run_actions_execution_loop then return end
    run_actions_execution_loop = true
    CreateTimeEvent(run_actions_execution_loop_name, run_actions_execution_loop_name, Settings.actions_execution_loop, npe_actions_execution_loop) -- offset time actions_execution_loop
    printdebug(LOG.START, LOG.EXEC," resumed actions execution loop")
end

local function remove_actions_execution_loop()
    printdebug(LOG.STOP, LOG.EXEC," removing actions execution loop")
    RemoveTimeEvent(run_actions_execution_loop_name, run_actions_execution_loop_name)
end

-- Context Countdowns loop
local run_context_countdowns_loop = false
local run_context_countdowns_name = 'NPE_Countdowns_Loop'
local context_countdowns_loop = 1
local function npe_context_countdowns_loop()
    printdebug(LOG.RUN, LOG.POOL," Context Countdown loop")
    if not run_context_countdowns_loop then return true end
    ResetTimeEvent(run_context_countdowns_name, run_context_countdowns_name, context_countdowns_loop)
    printdebug(LOG.RUN, LOG.EXEC," running context countdowns loop")
    update_queued_contexts_countdowns()

    return false
end
local function pause_context_countdowns_loop()
    printdebug(LOG.RUN, LOG.EXEC," pausing context countdowns loop")
    if not run_context_countdowns_loop then return end
    run_context_countdowns_loop = false
    printdebug(LOG.STOP, LOG.EXEC," paused context countdowns loop")
end

local function resume_context_countdowns_loop()
    printdebug(LOG.RUN, LOG.EXEC," resuming context countdowns loop")
    if run_context_countdowns_loop then return end
    run_context_countdowns_loop = true
    CreateTimeEvent(run_context_countdowns_name, run_context_countdowns_name, context_countdowns_loop, npe_context_countdowns_loop)
    printdebug(LOG.START, LOG.EXEC," resumed context countdowns loop")
end

local function remove_context_countdowns_loop()
    printdebug(LOG.STOP, LOG.EXEC," removing context countdowns loop")
    RemoveTimeEvent(run_context_countdowns_name, run_context_countdowns_name)
end

-- Play Queued loop
local run_play_loop = false
local play_loop_name = 'NPE_Play_Loop'

local function npe_play_loop()
    printdebug(LOG.RUN, LOG.POOL," Play loop")
    if not run_play_loop then return true end
    ResetTimeEvent(play_loop_name, play_loop_name, Settings.play_loop)
    printdebug(LOG.RUN, LOG.EXEC," running play loop")
    play_queued_set()

    return false
end

local function pause_play_loop()
    printdebug(LOG.RUN, LOG.EXEC," pausing play loop")    
    if not run_play_loop then return end
    run_play_loop = false
    printdebug(LOG.STOP, LOG.EXEC," paused play loop")
end

local function resume_play_loop()
    printdebug(LOG.RUN, LOG.EXEC," resuming play loop")
    if run_play_loop then return end
    run_play_loop = true
    CreateTimeEvent(play_loop_name, play_loop_name, Settings.play_loop, npe_play_loop) 
    printdebug(LOG.START, LOG.EXEC," resumed play loop")
end

local function remove_play_loop()
    printdebug(LOG.REMOVE, LOG.EXEC," removing play loop")
    RemoveTimeEvent(play_loop_name, play_loop_name)
end

-- Play Now loop
local run_play_now_loop = false
local play_now_loop_name = 'NPE_Play_Now_Loop'
local play_now_loop = 1
local function npe_play_now_loop()
    printdebug(LOG.RUN, LOG.POOL," Play Now loop")
    if not run_play_now_loop then return true end
    ResetTimeEvent(play_now_loop_name, play_now_loop_name, play_now_loop) 
    printdebug(LOG.RUN, LOG.EXEC," running play_now loop")
    play_now_set()

    return false
end

local function pause_play_now_loop()
    printdebug(LOG.RUN, LOG.EXEC," pausing play_now loop")
    if not run_play_now_loop then return end
    run_play_now_loop = false
    printdebug(LOG.STOP, LOG.EXEC," paused play_now loop")
end

local function resume_play_now_loop()
    printdebug(LOG.RUN, LOG.EXEC," resuming play_now loop")
    if run_play_now_loop then return end
    run_play_now_loop = true
    CreateTimeEvent(play_now_loop_name, play_now_loop_name, play_now_loop, npe_play_now_loop)
    printdebug(LOG.START, LOG.EXEC," resumed play_now loop")
end

local function remove_play_now_loop()
    printdebug(LOG.STOP, LOG.EXEC," removing play_now loop")
    RemoveTimeEvent(play_now_loop_name, play_now_loop_name)
end

-- Play queues manager
local run_play_queues_manager_loop = false
local play_queues_manager_loop_name = 'NPE_Play_Queues_Manager_Loop'
local queue_manager_loop = 1
local function play_queues_manager_loop()
    printdebug(LOG.RUN, LOG.POOL," Play Queues Manager loop")
    if not run_play_queues_manager_loop then return true end
    ResetTimeEvent(play_queues_manager_loop_name, play_queues_manager_loop_name, queue_manager_loop) -- offset time queue_manager_loop
    printdebug(LOG.RUN, LOG.EXEC," running play_queues_manager loop")
    -- manages the play queues
    if #playableHighPrioQueue.setsKeys > 0 then
        pause_play_loop()
        resume_play_now_loop()
        return
    else
        pause_play_now_loop()
    end

    if #playableQueue.setsKeys > 0 then
        resume_play_loop()
    else
        pause_play_loop()
    end

    return false
end

local function pause_play_queues_manager_loop()
    printdebug(LOG.RUN, LOG.EXEC," pausing play_queues_manager loop")
    if not run_play_queues_manager_loop then return end
    run_play_queues_manager_loop = false
    pause_play_loop()
    pause_play_now_loop()    
    printdebug(LOG.STOP, LOG.EXEC," paused play_queues_manager loop")
end

local function resume_play_queues_manager_loop()
    printdebug(LOG.RUN, LOG.EXEC," resuming play_queues_manager loop")
    if run_play_queues_manager_loop then return end
    run_play_queues_manager_loop = true
    CreateTimeEvent(play_queues_manager_loop_name, play_queues_manager_loop_name, queue_manager_loop, play_queues_manager_loop)
    printdebug(LOG.START, LOG.EXEC," resumed play_queues_manager loop")
end

local function remove_play_queues_manager_loop()
    printdebug(LOG.STOP, LOG.EXEC," removing play_queues_manager loop")
    remove_play_loop()
    remove_play_now_loop()
    RemoveTimeEvent(play_queues_manager_loop_name, play_queues_manager_loop_name)
end

-- NPE Activation

function Activate_contexts_on(event)
    printdebug(LOG.RUN, LOG.ACTIV," Activate contexts on [%s]", event.name)
    local setsKeys = find_sets_on(event)
    if setsKeys then
        printdebug(LOG.ADD, LOG.ACTIV," Found sets on [%s]", event.name)
        print_table(setsKeys)
        add_to_playable_queue(setsKeys)
        resume_play_queues_manager_loop()
    end
end

-- NPE Actions
-- needs a dedicated queue to manage the actions delays

function Execute_npe_action(action, setId)
    printdebug(LOG.RUN, LOG.ACTIV," Execute action [%s] on set [%s]", action.descr, setId)
    add_to_actions_queue(action)
    resume_actions_execution_loop()
end

-- Execution controls

function Resume_execution() 
    printdebug(LOG.RUN, LOG.EXEC," Resume execution")
    resume_play_queues_manager_loop()
    resume_execution_loop()
end

function Pause_Execution()
    printdebug(LOG.STOP, LOG.EXEC," Pause execution")
    pause_play_queues_manager_loop()
    pause_execution_loop()
end


-- Activation and Registration

local function activate_oneshot_event(event, callback)
    local f
    f = function() 
    printdebug(LOG.RUN, LOG.ACTIV," Callback for oneshot event ["..event.name .. "] activated")

    printdebug(LOG.REMOVE, LOG.RGSTR," Unregistering callback [" ..callback .. "]")
    UnregisterScriptCallback(callback, f)

    Activate_contexts_on(event)
    end
    return f
end

function Register_npe_callbacks()
    printdebug(LOG.RUN, LOG.RGSTR," Register npe callbacks")
    for setKey, context in pairs(npeSetsActivationQueue.contexts) do
        if context.event.handler.module ~= npe.MODULE_TYPE.NONE then
            if context.event.handler.module == npe.MODULE_TYPE.ANOMALY then
                printdebug(LOG.ADD, LOG.RGSTR," Registering ANOMALY callback [" .. context.event.handler.name .. "] for [".. context.event.name .. "]")
                RegisterScriptCallback(context.event.handler.name,activate_oneshot_event(context.event, context.event.handler.name))    
            else
                -- here I should enable the CUSTOM handlers (execute on actor_update) and the callbacks that will react to them
                if AddScriptCallback then
                    local callback_name = context.event.handler.module .. "_" .. context.event.handler.name
                    context.event.handler.callback_name = callback_name
                    add_to_execution_queue(context.event.handler)
                    if not RegisteredCustomCallbacks[callback_name] then
                        RegisteredCustomCallbacks[callback_name] = true
                        AddScriptCallback(callback_name)
                    end
                    printdebug(LOG.ADD, LOG.RGSTR," Registering CUSTOM callback [" .. callback_name .. "] for [".. context.event.name .. "]")
                    RegisterScriptCallback(callback_name,activate_oneshot_event(context.event, callback_name))
                end
            end
        end
    end
end

local function update_log()
    LOG = {
        -- NPE tag
        NPE = { tag = "[NPE]"},
        -- log types
        INFO = { tag = ""},
        START = { tag = "-"},
        STOP = { tag = "!"},
        ERROR = { tag = "!"},
        ADD = { tag = "-"},
        REMOVE = { tag = "!"},
        RUN = { tag = "//"},
        -- categories
        CONF = { tag = "[CONF]", enabled = npe_mcm.npe_get_setting("logs", "conf_logs")},
        OVERR = { tag = "[OVERR]", enabled = npe_mcm.npe_get_setting("logs", "overr_logs")},
        RGSTR = { tag = "[RGSTR]", enabled = npe_mcm.npe_get_setting("logs", "rgstr_logs")},
        POOL = { tag = "[POOL]", enabled = npe_mcm.npe_get_setting("logs", "pool_logs")},
        EXEC = { tag = "[EXEC]", enabled =  npe_mcm.npe_get_setting("logs", "exec_logs")},
        ACTIV = { tag = "[ACTIV]", enabled = npe_mcm.npe_get_setting("logs", "activ_logs")},
        QUEUE = { tag = "[QUEUE]", enabled = npe_mcm.npe_get_setting("logs", "queue_logs")},
        PLAY = { tag = "[PLAY]", enabled = npe_mcm.npe_get_setting("logs", "play_logs")},
        EVENT = { tag = "[EVENT]", enabled = npe_mcm.npe_get_setting("logs", "event_logs")},
        ACTION = { tag = "[ACTION]", enabled = npe_mcm.npe_get_setting("logs", "action_logs")},
        UI = { tag = "[UI]", enabled = npe_mcm.npe_get_setting("logs", "ui_logs")},
        UI_EXEC = { tag = "[UI_EXEC]", enabled = npe_mcm.npe_get_setting("logs", "ui_exec_logs")}
    }
    
end

local function update_settings()
    -- NPE FLAGS
    Dialog_in_use = false
    Dialog_name = nil
    -- NPE General Settings
    Settings.enable = npe_mcm.npe_get_setting("general", "enable")
    Settings.execution_loop = npe_mcm.npe_get_setting("general", "execution_loop")
    Settings.play_loop = npe_mcm.npe_get_setting("general", "play_loop")  
    Settings.sounds_set = npe_mcm.npe_get_setting("general", "sounds_set")  
    Settings.pause_game = npe_mcm.npe_get_setting("general", "pause_game")  
    -- NPE Logs Settings
    Settings.debug_logs = npe_mcm.npe_get_setting("logs", "debug_logs")
    -- Settings.conf_logs = npe_mcm.npe_get_setting("logs", "conf_logs")
    -- Settings.overr_logs = npe_mcm.npe_get_setting("logs", "overr_logs")
    -- Settings.rgstr_logs = npe_mcm.npe_get_setting("logs", "rgstr_logs")
    -- Settings.pool_logs = npe_mcm.npe_get_setting("logs", "pool_logs")
    -- Settings.exec_logs = npe_mcm.npe_get_setting("logs", "exec_logs")
    -- Settings.activ_logs = npe_mcm.npe_get_setting("logs", "activ_logs")
    -- Settings.queue_logs = npe_mcm.npe_get_setting("logs", "queue_logs")
    -- Settings.play_logs = npe_mcm.npe_get_setting("logs", "play_logs")
    -- Settings.event_logs = npe_mcm.npe_get_setting("logs", "event_logs")
    -- Settings.action_logs = npe_mcm.npe_get_setting("logs", "action_logs")
    -- Settings.ui_logs = npe_mcm.npe_get_setting("logs", "ui_logs")
    -- Settings.ui_exec_logs = npe_mcm.npe_get_setting("logs", "ui_exec_logs")
    printf(" Settings:")

    local function m_print_table(t, indent)
        if not t then
            return
        end
        indent = indent or ''
        for key, value in pairs(t) do
            if type(value) == 'table' then
                printf(indent .. '' .. key .. ':')
                m_print_table(value, indent .. '  ')
            else
                printf(indent .. key .. ': ' .. tostring(value))
            end
        end
    end    
    m_print_table(Settings)

    update_log()
    printlog(LOG.RUN, LOG.CONF," LOG:")
    print_table(LOG)

    SendScriptCallback("npe_on_log_update")
end

local function first_time_initialization()
    printlog(LOG.RUN, LOG.EXEC," First time initialization")
    -- npe Settings
    update_settings()
    
   -- update the npeConfig table with the Settings from the MCM
   update_decks_from_mcm()
   apply_overrides_to_decks()
   -- Use the function to print the npeConfig.decks table
   printlog(LOG.RUN, LOG.CONF," Decks")
   print_table(npeConfig.decks)
   printlog(LOG.RUN, LOG.CONF," Decks list Ended")

   -- update the queue with the contexts from the npeConfig table
   update_activation_queue()

    -- register the queued contexts with the npe_events
   Register_npe_callbacks()
   
   -- Use the function to print the npeSetsActivationQueue table
   printlog(LOG.RUN, LOG.CONF," Activation Queue:")
   print_table(npeSetsActivationQueue.contexts)
   printlog(LOG.RUN, LOG.CONF," Activation Queue list Ended")

end

local function npe_actor_on_first_update()
    printlog(LOG.RUN, LOG.EXEC," Actor on first update")
    -- initialize npe configuration
    first_time_initialization()

    -- starting all loops
    Resume_execution()    
    resume_context_countdowns_loop()

    -- activate the contexts on EVENT.GAME_START
    Activate_contexts_on(npe.EVENT.GAME_START)
    Activate_contexts_on(npe.EVENT.DLC_START)
end

local function mcm_on_option_change()
    printdebug(LOG.RUN, LOG.EXEC," On option change")
    -- pausing all loops
    Pause_Execution()
    pause_context_countdowns_loop()

    -- update npe configuration
    update_settings()

    update_decks_from_mcm()
    
    apply_overrides_to_decks()

    -- Use the function to print the npeConfig.decks table
    printdebug(LOG.RUN, LOG.CONF," Decks:")
    debug_table(npeConfig.decks)
    printdebug(LOG.RUN, LOG.CONF," Decks list Ended")

    -- upcate the queue with the contexts from the npeConfig table
    update_activation_queue()

    -- Use the function to print the npeSetsActivationQueue table
    printdebug(LOG.RUN, LOG.CONF," Activation Queue:")
    debug_table(npeSetsActivationQueue.contexts)
    printdebug(LOG.RUN, LOG.CONF," Activation Queue list Ended")
    -- register the queued contexts with the npe_events
    Register_npe_callbacks()

    -- resume all loops
    Resume_execution()
    resume_context_countdowns_loop()
end

local function teardown_npe()
    printlog(LOG.RUN, LOG.EXEC," Teardown")
	if Dialog_in_use then
        tear_down_dialog()
	end
    remove_context_countdowns_loop()
    remove_execution_loop()
    remove_actions_execution_loop()
    remove_play_queues_manager_loop()
end


if AddScriptCallback then
    AddScriptCallback("npe_on_log_update")
end
function on_game_start()
    RegisterScriptCallback("on_option_change", mcm_on_option_change)
    RegisterScriptCallback("actor_on_first_update", npe_actor_on_first_update)
    RegisterScriptCallback("actor_on_net_destroy", teardown_npe)
    RegisterScriptCallback("actor_on_before_death",teardown_npe)
end