
local npeConfig = {
    decks = {},
}

local npeSetsContextQueue = {
    contexts = {},
}

local playableQueue = {
    setsKeys = {},
}

local npeExecutionQueue = {
    handlers = {},
}

Settings = {
    debug_logs = true,
    enable = true,
    execution_loop = 3,
    play_loop = 10,
    sounds_set = "NPE"
}

RegisteredCustomCallbacks = {}

local function printlog(msg,...)
	msg = msg or " "
	
	if select('#', ...) ~= 0 then printf(string.format(msg,...))
	else printf(msg)
	end
end

local function printdebug(msg,...) -- debug logging
	if Settings.debug_logs then printlog(msg,...) end
end
Printlog_npe = printlog
Printdebug_npe = printdebug

local function map_to_set_key(moduleId, setId)
    return moduleId .. "/" .. setId
end

local function map_from_set_key(key)
    local split = string.gmatch(key, "[^/]+")
    local moduleId = split()
    local setId = split()
    return moduleId, setId
end

local function add_to_sets_queue(set, moduleId)
    -- printdebug("[NPE] add_to_sets_queue %s %s", moduleId, set.id)
    local setKey = map_to_set_key(moduleId, set.id)
    -- printdebug("[NPE] setKey %s", setKey)
    if set ~= nil then
        local context = {
            event = set.context.event,
            delay = set.context.delay,
            pause_game = set.context.pause_game,
        }
        if not context.event.handler.module then
            context.event.handler.module = moduleId
        end
        -- Check if a context with the same contextId already exists
        if npeSetsContextQueue.contexts[setKey] == nil then
            -- Add the new context to the table with contextId as the key
            npeSetsContextQueue.contexts[setKey] = context
            printdebug("[NPE] context with id [" .. setKey .. "] added to the queue with event [" .. context.event.name .. "] and module [" .. context.event.handler.module .. "]")
        else
            printlog("! [NPE] context with id [" .. setKey .. "] already exists.")
            printlog("! [NPE] context event [" .. context.event.name .. "] and module [" .. context.event.handler.module .. "]")
        end
    end
end

local function get_set_from_key(key)
    local moduleId, setId = map_from_set_key(key)
    local set = nil
    for i, deck in ipairs(npeConfig.decks) do
        if deck.module == moduleId then
            for j, setEntry in ipairs(deck.sets) do
                if setEntry.id == setId then
                    set = setEntry
                    break
                end
            end
        end
    end
    return set
end

local function add_to_playable_queue(setsKeys)
    if setsKeys == nil then
        return
    end

    for i, setKey in ipairs(setsKeys) do
        -- add set to the playable queue
        table.insert(playableQueue.setsKeys, setKey)
        -- removes it from the npeSetsContextQueue
        npeSetsContextQueue.contexts[setKey] = nil
    end
end

local function add_to_execution_queue(handler)
    if handler == nil then
        return
    end
    table.insert(npeExecutionQueue.handlers, handler)
end

function Add_deck(npeDeck)
    if npeDeck ~= nil then
        local deckExists = false
        for i, deck in ipairs(npeConfig.decks) do
            if deck.id == npeDeck.id then
                deckExists = true
                break
            end
        end
        if not deckExists then
            table.insert(npeConfig.decks, npeDeck)
        else
            printlog("! [NPE] Deck with id [" .. npeDeck.id .. "] already exists.")
        end
    end
end

local function update_decks_from_mcm()
    printdebug("// [NPE] Update decks from MCM")
    for i, deck in ipairs(npeConfig.decks) do
        for j, set in ipairs(deck.sets) do
            set.played = npe_mcm.npe_module_get_setting(deck.module, set.id)
            if set.context.event.handler.executed then
                set.context.event.handler.executed = false
            end
            if set.context.countdown then
                set.context.countdown = nil
            end
        end
    end
end



local function update_activation_queue()
    printdebug("// [NPE] Update activation queue")
    npeSetsContextQueue = {
        contexts = {},
    }
    for i, deck in ipairs(npeConfig.decks) do
        for j, set in ipairs(deck.sets) do
            -- Only call add_to_sets_queue if set.played is false
            if set.played == false then
                add_to_sets_queue(set, deck.module)
            end
        end
    end
end


local function print_table(t, indent)
    if not t then
        return
    end
    indent = indent or ''
    for key, value in pairs(t) do
        if type(value) == 'table' then
            printlog(indent .. '' .. key .. ':')
            print_table(value, indent .. '  ')
        else
            printlog(indent .. key .. ': ' .. tostring(value))
        end
    end
end
Print_table_npe = print_table

local function debug_table(t, indent)
    if not t then
        return
    end
    indent = indent or ''
    for key, value in pairs(t) do
        if type(value) == 'table' then
            printdebug(indent .. '' .. key .. ':')
            debug_table(value, indent .. '  ')
        else
            printdebug(indent .. key .. ': ' .. tostring(value))
        end
    end
end
Debug_table_npe = debug_table

local function compare_events(event1, event2)
    if event1.name ~= event2.name then
        return false
    end
    if event1.module ~= event2.module then
        return false
    end
    return true
end

local function find_sets_on(event)
    printdebug("[NPE] Find sets on %s", event.name)
    local setsKeys = {}
    for setKey, queued_context in pairs(npeSetsContextQueue.contexts) do
        if compare_events(queued_context.event, event) then
            printdebug("[NPE] queued context name [%s]", queued_context.event.name)
            table.insert(setsKeys, setKey)
        end
    end
    return setsKeys
end

function Activate_contexts_on(event)
    printdebug("// [NPE] Activate contexts on [%s]", event.name)
    local setsKeys = find_sets_on(event)
    if setsKeys then
        printdebug("- [NPE] Found sets on [%s]", event.name)
        print_table(setsKeys)
        add_to_playable_queue(setsKeys)
    end
end

local function run_execution_queue()
    printdebug("// [NPE] Run execution queue")
    for i, handler in ipairs(npeExecutionQueue.handlers) do
        if not handler.executed then
            printdebug("[NPE] Running handler [%s]", handler.name)
            local success = execute_func(unpack(handler.functor))   
            if success then
                printdebug("[NPE] Handler [%s] executed. Success: %s", handler.name, success)
                handler.executed = true
                if AddScriptCallback then
                    printdebug("[NPE] SendScriptCallback [%s]", handler.callback_name)
                    SendScriptCallback(handler.callback_name)
                    table.remove(npeExecutionQueue.handlers, i)
                end
            end
        end
    end
end

local function update_queued_contexts_countdowns()
    if playableQueue.setsKeys and #playableQueue.setsKeys > 0 then
        for i, setKey in ipairs(playableQueue.setsKeys) do
            local set = get_set_from_key(setKey)
            if set and set.context.countdown and set.context.countdown > 0 then
                printdebug("[NPE] Context [%s] countdown is %s", set.context.event.name, set.context.countdown)
                set.context.countdown = set.context.countdown - 1
            end
        end
    end
end

local function play_random_set(self)
    if playableQueue.setsKeys and #playableQueue.setsKeys > 0 then
        local randomIndex = math.random(#playableQueue)
        local setKey = table.remove(playableQueue.setsKeys, randomIndex)
        local set = get_set_from_key(setKey)
        if set ~= nil then
            if set.context.delay and set.context.delay > 0 then
                if not set.context.countdown then
                    printdebug("[NPE] Play Set [%s] has a delay of %s", set.id, set.context.delay)
                    set.context.countdown = set.context.delay
                    table.insert(playableQueue.setsKeys, setKey)
                    return
                elseif set.context.countdown > 0 then
                    printdebug("[NPE] Play Set [%s] countdown is %s", set.id, set.context.countdown)
                    table.insert(playableQueue.setsKeys, setKey)
                    return
                end
                -- countdown is over so we can play the set
            end
            local moduleId, unused = map_from_set_key(setKey)
            set.module = moduleId
            if not npe_dialog.GUI then
                printdebug("// [NPE] play_random_set")
                -- Call the function that will play the set
                printdebug("[NPE] Playing set [%s] from module [%s]", set.id, set.module)
                printdebug("[NPE] Set Title: [%s]", set.title)
                set.played = true
                npe_mcm.npe_module_set_setting(moduleId, set.id, true)
                printdebug("[NPE] starting dialog")
                Pause_Execution()
                npe_dialog.Play(set)
            else
                -- cannot play set, UI is busy. Put it back in the queue
                table.insert(playableQueue.setsKeys, setKey)
            end
        end
    end
end

---- NPE Execution ----

-- Execution loop
local run_execution_loop = false
local run_execution_loop_name = 'NPE_Execution_Loop'

local function npe_execution_loop()
    printdebug("// [NPE] Execution loop")
    if not run_execution_loop then return true end
    if ResetTimeEvent then
        ResetTimeEvent(run_execution_loop_name, run_execution_loop_name, Settings.execution_loop)
    end

    run_execution_queue()

    return false
end
local function pause_execution_loop()
    printdebug("[NPE] pausing contexts activation loop")
    run_execution_loop = false
end

local function resume_execution_loop()
    printdebug("[NPE] resuming contexts activation loop")
    run_execution_loop = true

    CreateTimeEvent(run_execution_loop_name, run_execution_loop_name, 10, npe_execution_loop) -- offset time 10 seconds
end

local function remove_execution_loop()
    RemoveTimeEvent(run_execution_loop_name, run_execution_loop_name)
end

-- Context Countdowns loop
local run_context_countdowns_loop = false
local run_context_countdowns_name = 'NPE_Countdowns_Loop'
local context_countdowns_loop = 1
local function npe_context_countdowns_loop()
    printdebug("// [NPE] Context Countdown loop")
    if not run_context_countdowns_loop then return true end
    ResetTimeEvent(run_context_countdowns_name, run_context_countdowns_name, context_countdowns_loop)

    update_queued_contexts_countdowns()

    return false
end
local function pause_context_countdowns_loop()
    printdebug("[NPE] pausing context countdowns loop")
    run_context_countdowns_loop = false
end

local function resume_context_countdowns_loop()
    printdebug("[NPE] resuming context countdowns loop")
    run_context_countdowns_loop = true
    CreateTimeEvent(run_context_countdowns_name, run_context_countdowns_name, 10, npe_context_countdowns_loop) -- offset time 10 seconds
end

local function remove_context_countdowns_loop()
    RemoveTimeEvent(run_context_countdowns_name, run_context_countdowns_name)
end

-- Play loop
local run_play_loop = false
local play_loop_name = 'NPE_Play_Loop'

local function npe_play_loop()
    printdebug("// [NPE] Play loop")
    if not run_play_loop then return true end
    ResetTimeEvent(play_loop_name, play_loop_name, Settings.play_loop)

    play_random_set()

    return false
end

local function pause_play_loop()
    printdebug("[NPE] pausing play loop")
    run_play_loop = false
end

local function resume_play_loop()
    if run_play_loop then return end
    printdebug("[NPE] resuming play loop")
    run_play_loop = true
    CreateTimeEvent(play_loop_name, play_loop_name, 10, npe_play_loop) -- offset time 10 seconds
end

local function remove_play_loop()
    RemoveTimeEvent(play_loop_name, play_loop_name)
end

-- execution controls

function Resume_execution() 
    resume_play_loop()
    resume_execution_loop()
end

function Pause_Execution()
    pause_play_loop()
    pause_execution_loop()
end



-- registered callbacks' handler
local function activate_oneshot_event(event, callback)
    local f
    f = function() 
    printdebug("// [NPE] Activate oneshot event ["..event.name .. "]")

    printdebug("[NPE] Unregistering callback [" ..callback .. "]")
    UnregisterScriptCallback(callback, f)

    Activate_contexts_on(event)
    end
    return f
end

function Register_npe_callbacks()
    printdebug("// [NPE] Register npe callbacks")
    for setKey, context in pairs(npeSetsContextQueue.contexts) do
        if context.event.handler.module ~= npe.MODULE_TYPE.NONE then
            if context.event.handler.module == npe.MODULE_TYPE.ANOMALY then
                printdebug("[NPE] Registering ANOMALY callback [" .. context.event.handler.name .. "] for [".. context.event.name .. "]")
                RegisterScriptCallback(context.event.handler.name,activate_oneshot_event(context.event, context.event.handler.name))    
            else
                -- here I should enable the CUSTOM handlers (execute on actor_update) and the callbacks that will react to them
                if AddScriptCallback then
                    local callback_name = context.event.handler.module .. "_" .. context.event.handler.name
                    context.event.handler.callback_name = callback_name
                    add_to_execution_queue(context.event.handler)
                    if not RegisteredCustomCallbacks[callback_name] then
                        RegisteredCustomCallbacks[callback_name] = true
                        AddScriptCallback(callback_name)
                    end
                    printdebug("[NPE] Registering CUSTOM callback [" .. callback_name .. "] for [".. context.event.name .. "]")
                    RegisterScriptCallback(callback_name,activate_oneshot_event(context.event, callback_name))
                end
            end
        end
    end
end

local function update_settings()
    Settings.debug_logs = npe_mcm.npe_get_setting("general", "debug_logs")
    Settings.enable = npe_mcm.npe_get_setting("general", "enable")
    Settings.execution_loop = npe_mcm.npe_get_setting("general", "execution_loop")
    Settings.play_loop = npe_mcm.npe_get_setting("general", "play_loop")  
    Settings.sounds_set = npe_mcm.npe_get_setting("general", "sounds_set")  
    Settings.pause_game = npe_mcm.npe_get_setting("general", "pause_game")  
end

local function first_time_initialization()

    -- npe Settings
    update_settings()
    
   -- update the npeConfig table with the Settings from the MCM
   update_decks_from_mcm()

   -- Use the function to print the npeConfig.decks table
   printlog("- [NPE] Decks")
   print_table(npeConfig.decks)
   printlog("- [NPE] Decks list Ended")

   -- update the queue with the contexts from the npeConfig table
   update_activation_queue()

    -- register the queued contexts with the npe_events
   Register_npe_callbacks()
   
   -- Use the function to print the npeSetsContextQueue table
   printlog("- [NPE] Activation Queue:")
   print_table(npeSetsContextQueue.contexts)
   printlog("- [NPE] Activation Queue list Ended")

end

local function npe_actor_on_first_update()

    -- initialize npe configuration
    first_time_initialization()

    -- starting all loops
    Resume_execution()    
    resume_context_countdowns_loop()

    -- activate the contexts on EVENT.GAME_START
    Activate_contexts_on(npe.EVENT.GAME_START)
end

local function on_option_change()
    -- pausing all loops
    Pause_Execution()
    pause_context_countdowns_loop()

    -- update npe configuration
    update_settings()

    update_decks_from_mcm()
    -- Use the function to print the npeConfig.decks table
    printdebug("- [NPE] Decks:")
    debug_table(npeConfig.decks)
    printdebug("- [NPE] Decks list Ended")

    -- upcate the queue with the contexts from the npeConfig table
    update_activation_queue()

    -- Use the function to print the npeSetsContextQueue table
    printdebug("- [NPE] Activation Queue:")
    debug_table(npeSetsContextQueue.contexts)
    printdebug("- [NPE] Activation Queue list Ended")
    -- register the queued contexts with the npe_events
    Register_npe_callbacks()

    -- resume all loops
    Resume_execution()
    resume_context_countdowns_loop()
end

function teardown_npe()
    printlog("// [NPE] Teardown")
	if npe_dialog.GUI ~= nil then
        npe_dialog.GUI:TearDown()
	end
    remove_context_countdowns_loop()
    remove_execution_loop()
    remove_play_loop()
end

function on_game_start()
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("actor_on_first_update", npe_actor_on_first_update)
    RegisterScriptCallback("actor_on_net_destroy", teardown_npe)
    RegisterScriptCallback("actor_on_before_death",teardown_npe)
end