
local npeConfig = {
    decks = {},
}

local npeSetsQueue = {
    contexts = {},
}

local playableQueue = {
    setsKeys = {},
}

CONTEXT_TYPE = {
    NONE = "NONE",
    EVENT = "EVENT",
    CUSTOM = "CUSTOM",
    FUNCTOR = "FUNCTOR",
}

EVENTS = {
    GAME_START = "Game Start",
    NPC_LOOTED = "NPC Looted",
    MUTANT_LOOTED = "Mutant Looted",
    DAMAGE_DEALT = "Damage Dealt",
    QUEST_COMPLETED = "Quest Completed",
    QUEST_ACCEPTED = "Quest Accepted",
    ACTOR_DEATH = "Death",
    ACTOR_HIT= "Hit Received",
    ACTOR_BLEEDING= "Bleeding",
    ACTOR_IRRADIATED = "Irradiated",
    ACTOR_STRESSED = "Stressed",
    ACTOR_HUNGRY = "Hungry",
    ACTOR_OVERWEIGHT = "Overweight",
    ACTOR_MAD = "Madness",
    ACTOR_SLEEP = "Sleep",
    ACTOR_RANK_UP = "Rank Up",
    ACTOR_LEVEL_UP = "Level Up",
    ACTOR_SKILL_UP = "Skill Up",
    ACTOR_PERK_UP = "Perk Up",
    ENTERED_RADIATION_FIELD = "Entered Radiation Field",
    ENTERED_ANOMALOUS_FIELD = "Entered Anomalous Field",
    STASH_COORDINATES_REVEALED = "Stash Coordinates Revealed",
}

FUNCTORS = {
    ITEM_LOOTED = "Item Looted", 
    ITEM_OWNED = "Item Owned",
    TALKED_TO_NPC = "Talked to NPC",
    DAMAGE_RECEIVED = "Damage Received",
    
}

settings = {
    debug_logs = true,
    enable = true,
    contextmatch_frequency = 3,
    play_frequency = 10
}


function printlog(msg,...)
	msg = msg or " "
	
	if select('#', ...) ~= 0 then printf(string.format(msg,...))
	else printf(msg)
	end
end

function printdebug(msg,...) -- debug logging
	if debug_logs then printlog(msg,...) end
end


local function mapToSetKey(moduleId, setId)
    return moduleId .. "/" .. setId
end

local function mapFromSetKey(key)
    local split = string.gmatch(key, "[^/]+")
    local moduleId = split()
    local setId = split()
    return moduleId, setId
end


local function AddToQueue(set, moduleId)
    local setKey = mapToSetKey(moduleId, set.id)
    if set ~= nil then
        local context = {
            type = set.context.type,
            qualifier = set.context.qualifier,
            functor = set.context.functor,
        }
        -- Check if a context with the same contextId already exists
        if npeSetsQueue.contexts[setKey] == nil then
            -- Add the new context to the table with contextId as the key
            npeSetsQueue.contexts[setKey] = context
        else
            printlog("context with id " .. setKey .. " already exists.")
        end
    end
end

local function getSetFromKey(key)
    local moduleId, setId = mapFromSetKey(key)
    local set = nil
    for i, deck in ipairs(npeConfig.decks) do
        if deck.module == moduleId then
            for j, setEntry in ipairs(deck.sets) do
                if setEntry.id == setId then
                    set = setEntry
                    break
                end
            end
        end
    end
    return set
end

local function addToPlayableQueue(setsKeys)
    if setsKeys == nil then
        return
    end

    for i, setKey in ipairs(setsKeys) do
        -- add set to the playable queue
        table.insert(playableQueue.setsKeys, setKey)
        -- removes it from the npeSetsQueue
        npeSetsQueue.contexts[setKey] = nil
    end
end

function AddConfig(npeDeck)
    if npeDeck ~= nil then
        local deckExists = false
        for i, deck in ipairs(npeConfig.decks) do
            if deck.id == npeDeck.id then
                deckExists = true
                break
            end
        end
        if not deckExists then
            table.insert(npeConfig.decks, npeDeck)
        else
            printlog("Deck with id " .. npeDeck.id .. " already exists.")
        end
    end
end

local function update_decks_from_mcm()
    
    for i, deck in ipairs(npeConfig.decks) do
        for j, set in ipairs(deck.sets) do
            set.played = npe_mcm.npe_module_get_setting(deck.module, set.id)
        end
    end
end



local function update_queue()

    npeSetsQueue = {
        contexts = {},
    }
    for i, deck in ipairs(npeConfig.decks) do
        for j, set in ipairs(deck.sets) do
            -- Only call AddToQueue if set.played is false
            if set.played == false then
                AddToQueue(set, deck.module)
            end
        end
    end
end
    

local function printTable(t, indent)
    if not t then
        return
    end
    indent = indent or ''
    for key, value in pairs(t) do
        if type(value) == 'table' then
            printlog(indent .. '' .. key .. ':')
            printTable(value, indent .. '  ')
        else
            printlog(indent .. key .. ': ' .. tostring(value))
        end
    end
end

function findEligibleSetsOn(qualifier)
    local setsKeys = {}
    for setKey, context in pairs(npeSetsQueue.contexts) do
        if context.qualifier == qualifier then
            table.insert(setsKeys, setKey)
        end
    end
    return setsKeys
end

function findEligibleSetsOnFunctor()
    printdebug("findEligibleSetsOnFunctor")
    local setsKeys = {}
    for setKey, context in pairs(npeSetsQueue.contexts) do
        printdebug("Checking set %s", setKey)
        if context.type == CONTEXT_TYPE.FUNCTOR and context.functor then
            printdebug(table.concat(context.functor, ', '))
            local success = execute_func(unpack(context.functor))
            printdebug("Functor %s executed. Success: %s", setKey, success)
            if success then
                table.insert(setsKeys, setKey)
            end
        end
    end
    return setsKeys
end

function findEligibleSetsContexts()
    local setsKeys = {}
    for setKey, context in pairs(npeSetsQueue.contexts) do
        if context.type == CONTEXT_TYPE.EVENT and context.type ~= EVENTS.GAME_START and context.qualifier then
            local eligibility = npe_events.Invoke[context.qualifier]()
            if eligibility then
                table.insert(setsKeys, setKey)
            end
        end
    end
    return setsKeys
end

local function playRandomSet(self)
    printdebug("playRandomSet")
    if playableQueue.setsKeys and #playableQueue.setsKeys > 0 then
        local randomIndex = math.random(#playableQueue)
        local key = table.remove(playableQueue.setsKeys, randomIndex)
        local set = getSetFromKey(key)
        if set ~= nil then
            local moduleId, unused = mapFromSetKey(key)
            -- Call the function that will play the set
            set.module = moduleId
            printdebug("Playing set %s from module %s", set.id, set.module)
            printdebug("Set Title: %s", set.title)
            set.played = true
            npe_mcm.npe_module_set_setting(moduleId, set.id, true)

            if not npe_dialog.GUI then
                if self then
                    self:On_Cancel()
                end
                printlog("[NPE] starting dialog")
                npe_dialog.play(set)
                pausePlayLoop()
            end
        end
    end
end

local runEligibilityMatchLoop = false
local playEligibilityMatchName = 'NPE_EligibilityMatch_Loop'

function NPEEligibilityMatchLoop()
    printdebug("[NPE] EligibilityMatch loop")
    if not runEligibilityMatchLoop then return true end
    ResetTimeEvent(playEligibilityMatchName, playEligibilityMatchName, settings.contextmatch_frequency)

    -- find matching sets with ContextType.FUNCTOR and check eligibility
    local setsKeys = findEligibleSetsOnFunctor()
    printdebug("//findEligibleSetsOnFunctor:")
    printTable(setsKeys)
    addToPlayableQueue(setsKeys)


    -- find matching sets with ContextType.EVENT and check eligibility
    setsKeys = findEligibleSetsContexts()
    printdebug("//findEligibleSetsContexts:")
    printTable(setsKeys)
    addToPlayableQueue(setsKeys)

    printdebug("- PlayableQueue:")
    printTable(playableQueue.setsKeys)

    return false
end
function pauseEligibilityMatchLoop()
    printlog("[NPE] pausing EligibilityMatch loop")
    runEligibilityMatchLoop = false
end

function resumeEligibilityMatchLoop()
    printlog("[NPE] resuming EligibilityMatch loop")
    runEligibilityMatchLoop = true
    CreateTimeEvent(playEligibilityMatchName, playEligibilityMatchName, 10, NPEEligibilityMatchLoop) -- offset time 10 seconds
end


local runPlayLoop = false
local playLoopName = 'NPE_Play_Loop'

function NPEPlayLoop()
    if not runPlayLoop then return true end
    ResetTimeEvent(playLoopName, playLoopName, settings.play_frequency)

    playRandomSet()

    return false
end
function pausePlayLoop()
    printlog("[NPE] pausing play loop")
    runPlayLoop = false
end

function resumePlayLoop()
    printlog("[NPE] resuming play loop")
    runPlayLoop = true
    CreateTimeEvent(playLoopName, playLoopName, 10, NPEPlayLoop) -- offset time 10 seconds
end

local function general_initialization()

    -- npe settings
    settings.debug_logs = npe_mcm.npe_get_setting("general", "debug_logs")
    settings.enable = npe_mcm.npe_get_setting("general", "enable")
    settings.contextmatch_frequency = npe_mcm.npe_get_setting("general", "contextmatch_frequency")
    settings.play_frequency = npe_mcm.npe_get_setting("general", "play_frequency")  
   -- update the npeConfig table with the settings from the MCM
   update_decks_from_mcm()

   -- Use the function to print the npeConfig.decks table
   printlog("- Decks:")
   printTable(npeConfig.decks)

   -- update the queue with the contexts from the npeConfig table
   update_queue()

   -- Use the function to print the npeSetsQueue table
   printlog("- Queue:")
   printTable(npeSetsQueue.contexts)

end

local function npe_actor_on_first_update()
    printlog(" npe_actor_on_first_update")

    general_initialization()

    local setsKeys = findEligibleSetsOn(EVENTS.GAME_START)
    printlog("Sets contexted on GAME_START:")
    printTable(setsKeys)

    addToPlayableQueue(setsKeys)

    printlog("- PlayableQueue:")
    printTable(playableQueue.setsKeys)

    printlog("[NPE] starting play loop")
    resumePlayLoop()
    printlog("[NPE] starting EligibilityMatch loop")
    resumeEligibilityMatchLoop()
end

local function on_option_change()
    update_decks_from_mcm()
    update_queue()
    -- Use the function to print the npeSetsQueue table
    printlog("- Queue:")
    printTable(npeSetsQueue.contexts)
end

function on_game_start()
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("actor_on_first_update", npe_actor_on_first_update)
    -- RegisterScriptCallback("actor_on_update", npe_actor_on_update)

 
    -- -- Events Callbacks
    -- RegisterScriptCallback("actor_on_sleep",actor_on_sleep) -- ACTOR_SLEEP
    -- RegisterScriptCallback("actor_on_hit_callback",actor_on_hit_callback) -- ACTOR_HIT
	-- RegisterScriptCallback("actor_on_weapon_fired", update_shooting_tg) -- DAMAGE_DEALT
    -- RegisterScriptCallback("actor_on_weapon_lower",actor_on_weapon_lower)

    -- -- Functors Callbacks
    -- RegisterScriptCallback("ActorMenu_on_item_focus_receive",ActorMenu_on_item_focus_receive)
    -- RegisterScriptCallback("actor_on_item_use",actor_on_item_use)
    -- RegisterScriptCallback("actor_item_to_slot",actor_item_to_slot)
end 