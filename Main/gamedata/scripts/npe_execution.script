
local printlog = npe_manager.Printlog_npe
local printdebug = npe_manager.Printdebug_npe
-- local print_table = npe_manager.Print_table_npe
LOG = npe_manager.LOG


local function print_table(t, indent)
    if not t then
        printlog(LOG.INFO, LOG.CONF, 'nil table')
        return
    end
    indent = indent or ''
    for key, value in pairs(t) do
        if type(value) == 'table' then
            printlog(LOG.INFO, LOG.CONF, indent .. '' .. key .. ':')
            print_table(value, indent .. '  ')
        else
            printlog(LOG.INFO, LOG.CONF, indent .. key .. ': ' .. tostring(value))
        end
    end
end

-- Execution Manager settings
local execution_manager_group_name = 'NPE_Execution_Manager' -- group name for the execution manager watch
local run_execution_manager_loop = false
-- Execution Watch settings
local execution_watch_name = 'NPE_Execution_Manager_Watch'
local run_execution_watch = false
local execution_watch_timer = 15
-- runners settings
local runners_default_group_name = 'NPE_Runners'

-- Execition types
TYPE = {
    INFINITE = "INFINITE",              -- never stops until disabled
    FINITE = "FINITE",                  -- stop after a number of loops
    CONDITIONAL = "CONDITIONAL",        -- stop when a condition is met
}   

RUNNER_CONFIG_TEMPLATE_NAME = {
    DEFAULT_INFINITE = "default_infinite",
    DEFAULT_FINITE = "default_finite",
    DEFAULT_CONDITIONAL = "default_conditional",
}

-- runner configuration templates
local DEFAULT_RUNNER_CONFIG = {
    
    default_infinite = {
        name = nil,                                 -- name of the runner, unique in the runners' group
        group_name = nil,                           -- name of the runners' group, default is runners_default_group_name
        exclusive = false,                          -- exclusive execution rights over runners of the same group
        execution = npe_execution.TYPE.INFINITE,    -- type of execution
        start_timer = 0,                            -- delay before starting the runner once enabled. paused runners will start immediately when resumed
        loop_timer = 1,                             -- delay between each loop
        loops = nil,                                -- number of loops before stopping the runner
        max_life = nil,                             -- maximum life time of the runner in seconds before the execution_watch stops it
        autoremove = false,                         -- execution_watch removes the runner when it reaches its max life time
        stop_condition = nil,                       -- a function to stop the runner conditionally
        functor = nil                               -- the function to execute
        -- functor and stop_condition interface 
        -- functor[1]: script name
        -- functor[2]: function name
        -- functor[3-n]: parameters
    },
    default_finite = {
        name = nil,
        group_name = nil,  
        exclusive = false,      
        execution = npe_execution.TYPE.FINITE,
        start_timer = 0,
        loop_timer = 1,
        loops = nil,
        max_life = nil,
        autoremove = false,
        stop_condition = nil,        
        functor = nil
    },
    default_conditional = {
        name = nil,
        group_name = nil,
        exclusive = false,
        execution = npe_execution.TYPE.CONDITIONAL,
        start_timer = 0,
        loop_timer = 1,
        loops = nil,
        max_life = nil,
        autoremove = false,
        stop_condition = nil,        
        functor = nil
    }        
}

-- a template to create a new runner
local RUNNER_TEMPLATE = {
    default = {
        name = nil,                                 -- set at creation, using the runner configuration name
        group_name = nil,                           -- set at creation, using the runner configuration group_name or default
        config = nil,                               -- set at creation
        -- runner execution control related fields 
        enabled = false,                            -- manage execution
        exclusive = false,                          -- determine execution rights over runners of the same group
        running = false,                            -- running state (a timed event is active)   
        -- runner execution state related fields         
        executing = false,                          -- execution state (a timed event is executing the functor)        
        paused = false,                             -- runner is on paused state   
        unscheduled = false,                        -- runner execution group related fields         
        loop_count = 0,                             -- internal counter
        life = 0,                                   -- internal timer set on Add
        stop_condition_met = false,                 -- internal state, only used to break conditional runners loops
    },  
}


-- NPE Execution Manager Tables

-- the runners list 
local Runner = {}

-- the execution group list
local Execution_group = {}

-- runner local api

-- runner execution state management

local function stop_runner(runner_name)
    if not Runner[runner_name].enabled then return end -- runner is already disabled
    printdebug(LOG.STOP, LOG.NPE_EXE," Runner: " .. runner_name .. " disabled")
    Runner[runner_name].enabled = false
    if Runner[runner_name].exclusive then
        Execution_group[Runner[runner_name].group_name].exclusive_run = false
    end
end

local function unschedule_runner(runner_name)
    if Runner[runner_name].unscheduled then return end -- runner is already unscheduled
    printdebug(LOG.STOP, LOG.NPE_EXE," Runner: " .. runner_name .. " unscheduled")
    Runner[runner_name].enabled = false
    Runner[runner_name].unscheduled = true
end

local function start_runner(runner_name)
    if Runner[runner_name].enabled then return end -- runner is already enabled
    printdebug(LOG.START, LOG.NPE_EXE," Runner: " .. runner_name .. " enabled")
    Runner[runner_name].enabled = true
    if Runner[runner_name].exclusive then
        Execution_group[Runner[runner_name].group_name].exclusive_run = true
    end
end

local function reschedule_runner(runner_name)
    if not Runner[runner_name].unscheduled then return end -- runner is already scheduled
    printdebug(LOG.START, LOG.NPE_EXE," Runner: " .. runner_name .. " rescheduled")
    Runner[runner_name].enabled = true
end

local function pause_runner(runner_name)
    if Runner[runner_name].paused then return end  -- runner is already paused
    printdebug(LOG.STOP, LOG.NPE_EXE," Runner: " .. runner_name .. " paused")
    Runner[runner_name].enabled = false
    Runner[runner_name].paused = true
    if Runner[runner_name].exclusive then
        Execution_group[Runner[runner_name].group_name].exclusive_run = false
    end
end

local function reset_state(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " reset")
    Runner[runner_name].loop_count = 0
    Runner[runner_name].stop_condition_met = false
end

-- runner state management

local function set_running(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " running")
    Runner[runner_name].running = true
end

local function unset_running(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " stopped")
    Runner[runner_name].running = false
end

local function set_executing(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " executing")
    Runner[runner_name].executing = true
end

local function unset_executing(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " not executing")
    Runner[runner_name].executing = false
end

local function set_unscheduled(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " unscheduled")
    Runner[runner_name].unscheduled = true
end

local function unset_unscheduled(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " rescheduled")
    Runner[runner_name].unscheduled = false
end

local function set_paused(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " paused")
    Runner[runner_name].paused = true
end

local function unset_paused(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " unpaused")
    Runner[runner_name].paused = false
end

local function set_stop_condition_met(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " stop_condition_met")
    Runner[runner_name].stop_condition_met = true
end

local function is_enabled(runner_name)
    return Runner[runner_name].enabled
end

local function get_life(runner_name)
    return math.floor((time_global() - Runner[runner_name].life)/1000)
end

local function increase_loop_count(runner_name)
    Runner[runner_name].loop_count = Runner[runner_name].loop_count + 1
end

-- functor handler

local execute_functor = function(runner_name)
    -- the functor's handler or timed event
    -- these are perpetualy timed event which can only be stopped if runner is disabled
    -- usually the run function will stop the runner if certain conditions are met
    -- client scripts can stop the runner by calling the Pause/Remove functions
    -- print_table(params)
    local runner = Runner[runner_name]
    -- check if the functor's runner has been removed, if so stop the execution
    if not runner then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner is null")
        return true 
    end
    printdebug(LOG.RUN, LOG.NPE_EXE," Functor Execution: " .. runner.name)
    if not is_enabled(runner_name) then 
        -- the runner is disabled, stop the execution state of timed event
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner is disabled at loop: " .. runner.loop_count)
        -- stop the timed event
        unset_running(runner_name)
        unset_executing(runner_name)
        return true 
    end

    if runner.config.execution == TYPE.CONDITIONAL and runner.config.stop_condition then
        -- check the stop condition
        if execute_func(unpack(runner.config.stop_condition)) then
            printdebug(LOG.INFO, LOG.NPE_EXE," Stop Condition met")
            set_stop_condition_met(runner_name)
            return true
        end
    end

    -- reset this timed event timer for the next execution loop
    ResetTimeEvent(runner.group_name, runner.name, runner.config.loop_timer)
    
    -- runner is executing
    set_executing(runner_name)

    -- update the loop count
    increase_loop_count(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Executed Runner: " .. runner.name .. " Loop: " .. runner.loop_count)

    -- execute the functor
    -- print_table(runner.config.functor)
    execute_func(unpack(runner.config.functor))

    -- keeps running as long as the runner is enabled
    return false
end

-- runner handler
-- called on every actor update when runner is enabled
local function run(runner_name)

    local runner = Runner[runner_name]
    if not runner.running then
        -- instantiate if not running
        local create_timer = runner.config.start_timer
        if runner.paused then -- the runner was enabled while paused 
            -- runner was paused, remove the pause state
            unset_paused(runner_name)
            create_timer = 0 -- start immediately from the paused/unscheduled state
        elseif runner.unscheduled then -- the runner was enabled while unscheduled
            -- runner was unscheduled, remove the unscheduled state
            unset_unscheduled(runner_name)
            create_timer = 0 -- start immediately from the paused/unscheduled state
        else
            -- reset the runner state
            reset_state(runner_name)
        end
        set_running(runner_name)
        CreateTimeEvent(runner.group_name, runner.name, create_timer, execute_functor, runner_name)
        printlog (LOG.INFO, LOG.NPE_EXE," Runner: " .. runner.name .. " started with timer " .. create_timer)
    else
        -- otherwise try to stop the runner

        -- check if another exclusive runner is running
        -- if so, unschedule the runner
        if not runner.exclusive and Execution_group[runner.group_name].exclusive_run then
            unschedule_runner(runner_name)
        end
        -- handle the runner execution type
        if runner.config.execution == TYPE.INFINITE then
            -- do nothing, the runner is infinite
        elseif runner.config.execution == TYPE.FINITE then
            -- check the loop count
            if runner.loop_count >= runner.config.loops then
                printdebug(LOG.STOP, LOG.NPE_EXE," Reached maximum loops")
                -- terminate the runner
                stop_runner(runner_name)
            end
        elseif runner.config.execution == TYPE.CONDITIONAL then
            -- check the stop_condition is met
            if runner.stop_condition_met then
                -- terminate the runner
                stop_runner(runner_name)
            end
        else
            printdebug(LOG.ERROR, LOG.NPE_EXE," Execution type " .. runner.config.execution .. " not supported")
        end
    end
end

-- Execution Manager or runners manager
-- called on every actor update when the callback is registered - @Manager_start()
local function execution_manager()
    -- for each Runner
    for runner_name, runner in pairs(Runner) do
        if runner.enabled then
            run(runner_name)
        elseif runner.unscheduled and not Execution_group[runner.group_name].exclusive_run then
            reschedule_runner(runner_name)
        end
    end
end

-- Execution Manager Watch

local function execution_watch()
    printdebug(LOG.RUN, LOG.NPE_EXE," Execution Manager watch loop")
    if not run_execution_manager_loop then return true end -- stop the watch
    -- reset the timer
    ResetTimeEvent(execution_manager_group_name, execution_watch_name, execution_watch_timer)

    -- watch execution manager
    if run_execution_manager_loop then
        printlog(LOG.START, LOG.NPE_EXE," Execution Manager running")
    end
    -- watch runners
    for runner_name, runner in pairs(Runner) do
        printdebug(LOG.START, LOG.NPE_EXE," Runner: [" .. runner_name .. "] in group [" .. runner.group_name .. "], exclusive[" .. tostring(runner.exclusive) .. "]") 
        local log_type = LOG.INFO
        if not runner.enabled or not runner.running or runner.paused or runner.unscheduled then
            log_type = LOG.ERROR
        end
        printdebug(log_type, LOG.NPE_EXE,"  -       enabled[" .. tostring(runner.enabled) .. "], running[" .. tostring(runner.running) .. "], paused[" .. tostring(runner.paused) ..  "], unscheduled[" .. tostring(runner.unscheduled) .. "]")
        printdebug(log_type, LOG.NPE_EXE,"  -       loop_count[" .. runner.loop_count .. "], life[" .. get_life(runner_name) .. "] seconds, max_life[" .. tostring(runner.config.max_life) .. "]")
        if runner.config.max_life and get_life(runner_name) > runner.config.max_life then
            printdebug(LOG.STOP, LOG.NPE_EXE," Runner: " .. runner.name .. " reached max life")
            stop_runner(runner_name)
            if runner.config.autoremove then
                Remove(runner_name)
            end
        end
    end
    -- keep watching
    return false
end

local function watch()
    if run_execution_watch then return end
    run_execution_watch = true
    CreateTimeEvent(execution_manager_group_name, execution_watch_name, execution_watch_timer, execution_watch)
end

local function unwatch()
    if not run_execution_watch then return end
    run_execution_watch = false
    RemoveTimeEvent(execution_manager_group_name, execution_watch_name)
end

-- Execution Manager API

function Manager_start()
    RegisterScriptCallback("actor_on_update", execution_manager)
    printlog(LOG.START, LOG.NPE_EXE," Execution Manager started")
    if run_execution_manager_loop then return end
    run_execution_manager_loop = true
    watch()
end

function Manager_stop()
    UnregisterScriptCallback("actor_on_update", execution_manager)
    printlog(LOG.STOP, LOG.NPE_EXE," Execution Manager stopped")
    if not run_execution_manager_loop then return end
    run_execution_manager_loop = false
    for runner_name, runner in pairs(Runner) do
        Remove(runner_name)
    end
    unwatch()
end

function Is_running()
    return run_execution_manager_loop
end

-- Runners' internal API

-- creates runner instances

local function copy(obj, seen)
    if type(obj) ~= 'table' then return obj end
    if seen and seen[obj] then return seen[obj] end
    local s = seen or {}
    local res = setmetatable({}, getmetatable(obj))
    s[obj] = res
    for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
    return res
end
local function get_instance(runner_template)
    return copy(runner_template)
end

-- runner config validation functions

local function validate_config(runner_config)
    if not runner_config then
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner configuration is null") 
        return false 
    end
    if not runner_config.name then
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner name is null") 
        return false 
    end
    printdebug(LOG.RUN, LOG.NPE_EXE," Validate Runner Configuration: " .. runner_config.name)
    if not runner_config.group_name then
        runner_config.group_name = runners_default_group_name -- TODO check this
        printdebug(LOG.ADD, LOG.NPE_EXE," Runner group name is null, set to " .. runner_config.group_name)
        -- runners in the runners_default_group_name cannot use exclusive execution
        runner_config.exclusive = false -- TODO check this
    end
    if not runner_config.start_timer then
        runner_config.start_timer = 0 -- TODO check this
        printdebug(LOG.ADD, LOG.NPE_EXE," Runner start timer is null, set to 0")
    end
    if not runner_config.loop_timer then
        runner_config.loop_timer = 1 -- TODO check this
        printdebug(LOG.ADD, LOG.NPE_EXE," Runner loop timer is null, set to 1")
    end
    if not runner_config.execution then
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner execution type is null") 
        return false 
    end
    if not runner_config.functor then
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner functor is null") 
        return false 
    end
    printdebug(LOG.ADD, LOG.NPE_EXE," Runner configuration validated")
    return true
end

-- functor and stop_condition validation

local function validate_functor(functor)
    printdebug(LOG.RUN, LOG.NPE_EXE," Validate Functor")
    if not functor then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Functor is null")
        return false 
    end
    -- checks is a table
    if type(functor) ~= "table" then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Functor is not a table")
        return false 
    end
    -- checks mandatory fields (script, function)
    if #functor < 2 then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Functor has less than 2 parameters")
        return false 
    end
    if type(functor[1]) ~= "string" then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Functor script name is not a string")
        return false 
    end
    if type(functor[2]) ~= "string" then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Functor function name is not a string")
        return false 
    end

    -- validated
    printdebug(LOG.ADD, LOG.NPE_EXE," Functor validated")
    return true
end

-- Runners' Execution API

function Add(runner_config)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    printdebug(LOG.RUN, LOG.NPE_EXE," Add Runner")
    if not validate_config(runner_config) then return end

    -- add the new runner to the list Runner
    if not Runner[runner_config.name] then
        -- create a new runner instance
        local new_runner_instance = get_instance(RUNNER_TEMPLATE.default)
        new_runner_instance.name = runner_config.name
        new_runner_instance.group_name = runner_config.group_name
        new_runner_instance.exclusive = runner_config.exclusive 
        new_runner_instance.config = runner_config

        -- functor is mandatory, must validate the functor's parameters
        local validation = validate_functor(new_runner_instance.config.functor)
        if not validation then
            printdebug(LOG.ERROR, LOG.NPE_EXE," Execution functor parameters are invalid")
            printdebug(LOG.ERROR, LOG.NPE_EXE," Runner is rejected")
            return false
        end
        
        -- stop_condition is optional
        if new_runner_instance.config.stop_condition then
            validation = validate_functor(new_runner_instance.config.stop_condition)
            if not validation then
                printdebug(LOG.ERROR, LOG.NPE_EXE," Stop condition functor parameters are invalid")
                printdebug(LOG.ERROR, LOG.NPE_EXE," Runner is rejected")
                return false
            end
            -- inject_runner_name(new_runner_instance.config.stop_condition, new_runner_instance.name)
        end

        -- passed validation
        new_runner_instance.config.validated = true

        -- add the new runner to the execution group list
        if not Execution_group[new_runner_instance.group_name] then
            local members = {}
            table.insert(members, new_runner_instance.name)
            Execution_group[new_runner_instance.group_name] = { exclusive_run = false, members = members}
        else
            table.insert(Execution_group[new_runner_instance.group_name].members, new_runner_instance.name)
        end        

        -- add the new runner to Runner list using runner_name as key
        Runner[new_runner_instance.name] = new_runner_instance
        -- set the life time
        Runner[new_runner_instance.name].life = time_global()
        printdebug(LOG.ADD, LOG.NPE_EXE," Runner: " .. new_runner_instance.name .. " added")
    else
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner: " .. runner_config.name .. " already exists")
    end
end

function Add_from_template(runner_name, runner_template)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    printdebug(LOG.RUN, LOG.NPE_EXE," Add Runner from template")
    if not runner_name then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner name is null")
        return 
    end
    if not runner_template then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner template is null")
        return 
    end
    if not DEFAULT_RUNNER_CONFIG[runner_template] then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner template: " .. runner_template .. " does not exist")
        return 
    end
    local runner_config = copy(DEFAULT_RUNNER_CONFIG[runner_template])
    runner_config.name = runner_name
    Add(runner_config)
end

function Remove(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    -- I need to remove a runner from the list Runner
    if not runner_name then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner name is null")
        return 
    end
    local runner = Runner[runner_name]
    if runner then 
        RemoveTimeEvent(runner.group_name, runner.name)
        Runner[runner_name] = nil
        printdebug(LOG.REMOVE, LOG.NPE_EXE," Runner: " .. runner_name .. " removed")
    else
        printdebug(LOG.ERROR, LOG.NPE_EXE," Removing Runner: " .. runner_name .. " does not exist")
    end
end

function Stop(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if not runner_name then return end
    if Runner[runner_name] then
        stop_runner(runner_name)
    end
end

function Pause(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if not runner_name then return end
    if Runner[runner_name] then
        pause_runner(runner_name)
    end
end

function Resume(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if not runner_name then return end
    if Runner[runner_name] then
        start_runner(runner_name)
    end
end

-- runners utility API

function Get_runner_count(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] and Runner[runner_name].enabled then
        return Runner[runner_name].loop_count
    else
        return -1
    end
end

function Is_runner_running(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] then
        return Runner[runner_name].running
    else
        return false
    end
end

function Is_runner_enabled(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] then
        return Runner[runner_name].enabled
    else
        return false
    end
end

function Is_runner_paused(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] then
        return Runner[runner_name].paused
    else
        return false
    end
end

--- *********************************** CLIENT EXAMPLE SCRIPT *********************************** ---

-- this part belongs to a client script

local my_items_queue = {
    items = {},
}

-- a functor used to consume items from the queue and print them
-- operates in the client namespace context
function print_items(runner_name, command, action)
    printdebug(LOG.RUN, LOG.NPE_EXE," Functor print_items")
    -- print_table(params)
    printdebug(LOG.INFO, LOG.NPE_EXE," Command: " .. command)
    printdebug(LOG.INFO, LOG.NPE_EXE," Action: " .. action)

    if my_items_queue.items and #my_items_queue.items > 0 then
        -- I need to remove the first item from the queue, and print it
        local item = table.remove(my_items_queue.items, 1)
        printdebug(LOG.INFO, LOG.NPE_EXE," Queue: " .. #my_items_queue.items)
        printdebug(LOG.INFO, LOG.NPE_EXE," Item: " .. item)
    else 
        printdebug(LOG.INFO, LOG.NPE_EXE," Items Queue is empty")
        npe_execution.Stop(runner_name)
        SendScriptCallback("client_queue_empty")
    end
    return true
end

local my_cards_queue = {
    cards = {},
}

-- a functor used to consume cards from the queue and print them
function print_cards(runner_name, command, action)
    printdebug(LOG.RUN, LOG.NPE_EXE," Functor print_cards")
    -- print_table(params)
    printdebug(LOG.INFO, LOG.NPE_EXE," Command: " .. command)
    printdebug(LOG.INFO, LOG.NPE_EXE," Action: " .. action)

    if my_cards_queue.cards and #my_cards_queue.cards > 0 then
        -- I need to remove the first item from the queue, and print it
        local item = table.remove(my_cards_queue.cards, 1)
        printdebug(LOG.INFO, LOG.NPE_EXE," Queue: " .. #my_cards_queue.cards)
        printdebug(LOG.INFO, LOG.NPE_EXE," Card: " .. item)
    else 
        printdebug(LOG.INFO, LOG.NPE_EXE," Cards Queue is empty")
        -- npe_execution.Stop(runner_name)
    end
end

local my_decks_queue = {
    decks = {},
}

function add_to_deck(item_to_add)
    printdebug(LOG.RUN, LOG.NPE_EXE," Functor add_deck")
    printdebug(LOG.INFO, LOG.NPE_EXE," item_to_add: " .. item_to_add)

    if my_decks_queue.decks then
        -- I need to add a deck to the queue
        local item = item_to_add .. " " .. tostring(#my_decks_queue.decks + 1)
        table.insert(my_decks_queue.decks, item)
        printdebug(LOG.INFO, LOG.NPE_EXE," Queue: " .. #my_decks_queue.decks)
    end
end

-- a function used to stop the runner conditionally after a number of loops
-- returns true if runner loop_count >= max_loops, false otherwise
function maximum_loops(runner_name, description, max_loops)
    printdebug(LOG.RUN, LOG.NPE_EXE," Stop Condition")

    printdebug(LOG.INFO, LOG.NPE_EXE, description .. " " .. max_loops)
    local loop_count = npe_execution.Get_runner_count(runner_name)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " loop_count: " .. loop_count)
    -- Client can use directly the npe_execution API
    if loop_count >= max_loops then
        printdebug(LOG.INFO, LOG.NPE_EXE," Reached maximum loops")
        return true
    end
    return false
end

-- default runner configuration created by the client script

local CLIENT_RUNNER_CONFIG = {
    default_infinite = {
        name = "default_infinite",
        execution = npe_execution.TYPE.INFINITE,
        start_timer = 10,
        loop_timer = 15,
        loops = nil,
        max_life = 100,
        autoremove = true,
        stop_condition = nil,        
        functor = { "npe_execution", "print_items", "default_infinite", "run", "consume and print_items" }
        -- functor and stop_condition interface 
        -- functor[1]: script name
        -- functor[2]: function name
        -- functor[3-n]: parameters      
    },
    default_finite = {
        name = "default_finite",
        execution = npe_execution.TYPE.FINITE,
        start_timer = 0,
        loop_timer = 2,
        loops = 15,
        stop_condition = nil,        
        functor = { "npe_execution", "print_cards", "default_finite", "run", "consume and print_cards" }
    },
    default_conditional = {
        name = "default_conditional",
        execution = npe_execution.TYPE.CONDITIONAL,
        start_timer = 10,
        loop_timer = 2,
        loops = nil,
        stop_condition = { "npe_execution", "maximum_loops", "default_conditional", " stop when loop count is ", 5 },
        functor = { "npe_execution", "add_to_deck", "run", "default_conditional" }
    },
    non_exclusive_1 = {
        name = "non_exclusive_1",
        group_name = "test_exclusive",  
        exclusive = false,
        execution = npe_execution.TYPE.FINITE,
        start_timer = 0,
        loop_timer = 2,
        loops = 10,
        -- max_life = 100,
        -- autoremove = true,
        -- stop_condition = nil,        
        functor = { "npe_execution", "add_to_deck", "non_exclusive_1_item" }
    },
    non_exclusive_2 = {
        name = "non_exclusive_2",
        group_name = "test_exclusive",  
        exclusive = false,
        execution = npe_execution.TYPE.FINITE,
        start_timer = 0,
        loop_timer = 2,
        loops = 10,
        -- max_life = 100,
        -- autoremove = true,
        -- stop_condition = nil,        
        functor = { "npe_execution", "add_to_deck", "non_exclusive_2_item" }
    },    
    exclusive_1 = {
        name = "EXCLUSIVE_1",
        group_name = "test_exclusive",
        exclusive = true, 
        execution = npe_execution.TYPE.FINITE,
        start_timer = 5,
        loop_timer = 2,
        loops = 10,
        -- max_life = 100,
        -- autoremove = true,
        -- stop_condition = nil,        
        functor = { "npe_execution", "add_to_deck", "exclusive_1" }
    },                
}


-- fill queue callback, shows how to resume the runner

local fill_count = 2
local function fill_queue()
    printlog(LOG.RUN, LOG.NPE_EXE," Fill Queue")
    if fill_count <= 0 then return end
    printdebug(LOG.INFO, LOG.NPE_EXE," Fill coount " .. fill_count)
    for i = 1, 10 do
        table.insert(my_items_queue.items, "item" .. tostring(i))
    end
    fill_count = fill_count - 1
    npe_execution.Resume("default_infinite")
end

-- client on actor update, shows how to add a runner and start it 

local function fill_items_queues()
    for i = 1, 20 do
        table.insert(my_items_queue.items, "item" .. tostring(i))
    end
end
local function fill_cards_queues()
    for i = 1, 20 do
        table.insert(my_cards_queue.cards, "card" .. tostring(i))
    end
end

local run_toggle_loop = false
local can_stop = false
function toggle_finite_runner() -- timed event
    printdebug(LOG.RUN, LOG.NPE_EXE," Toggle Finite Runner")
    if not run_toggle_loop then return true end
    if npe_execution.Is_running() then
        if not can_stop then
            if npe_execution.Is_runner_enabled(CLIENT_RUNNER_CONFIG.default_finite.name) then
                printdebug(LOG.RUN, LOG.NPE_EXE," toggle_finite_runner Pause Runner")
                -- pause the runner without resetting its state (loop count)
                npe_execution.Pause(CLIENT_RUNNER_CONFIG.default_finite.name)
                ResetTimeEvent("test_runner", "toggle_finite_runner_execution", 10)
            else
                printdebug(LOG.ADD, LOG.NPE_EXE,"toggle_finite_runner Resume Runner")
                npe_execution.Resume(CLIENT_RUNNER_CONFIG.default_finite.name)
                ResetTimeEvent("test_runner", "toggle_finite_runner_execution", 60)
                can_stop = true
            end
        else
            printdebug(LOG.STOP, LOG.NPE_EXE," toggle_finite_runner STOP Runner")
            -- stop the runner and resets its state (loop count)
            npe_execution.Stop(CLIENT_RUNNER_CONFIG.default_finite.name)
            run_toggle_loop = false
            -- kill the timed event
            return true
        end
    else
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        run_toggle_loop = false
        -- kill the timed event
        return true
    end
    -- keep running
    return false
end


function resume_exclusive_runner() -- timed event
    printdebug(LOG.RUN, LOG.NPE_EXE," Resume Exclusive Runner")
    if npe_execution.Is_running() then
        npe_execution.Resume(CLIENT_RUNNER_CONFIG.exclusive_1.name)
    else
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
    end
    -- one shot event
    return true
end

-- end test callback, shows how to remove the runner

local function end_test()  -- timed event
    printlog(LOG.STOP, LOG.NPE_EXE," End Client Test")
    run_toggle_loop = false
    RemoveTimeEvent("test_runner", "toggle_finite_runner_execution")
    npe_execution.Remove(CLIENT_RUNNER_CONFIG.default_infinite.name)
    npe_execution.Remove(CLIENT_RUNNER_CONFIG.default_finite.name)
    npe_execution.Remove(CLIENT_RUNNER_CONFIG.default_conditional.name)
    npe_execution.Remove(CLIENT_RUNNER_CONFIG.non_exclusive_1.name)
    npe_execution.Remove(CLIENT_RUNNER_CONFIG.non_exclusive_2.name)
    npe_execution.Remove(CLIENT_RUNNER_CONFIG.exclusive_1.name)
    -- print the table my_items_queue.items
    printdebug(LOG.INFO, LOG.NPE_EXE," Items Queue")
    print_table(my_items_queue.items)    
    -- print the table my_cards_queue.cards
    printdebug(LOG.INFO, LOG.NPE_EXE," Cards Queue")
    print_table(my_cards_queue.cards)
    -- print the table my_decks_queue.decks
    printdebug(LOG.INFO, LOG.NPE_EXE," Decks Queue")
    print_table(my_decks_queue.decks)
    -- kill the timed event
    npe_execution.Manager_stop()
    return true
end

local function start_test_infinite()
    fill_items_queues()
    -- -- create an infinite runner wich will consume an item every 30 seconds
    npe_execution.Add(CLIENT_RUNNER_CONFIG.default_infinite)
    npe_execution.Resume(CLIENT_RUNNER_CONFIG.default_infinite.name)
end

local function start_test_finite()
    fill_cards_queues()
    -- create an finite runner wich will consume 10 cards from the queue
    npe_execution.Add(CLIENT_RUNNER_CONFIG.default_finite)
    npe_execution.Resume(CLIENT_RUNNER_CONFIG.default_finite.name)
    -- toggle the finite runner execution at 15 seconds in the run, to then pause it for 10 seconds
    -- this  to test that the loop count is persistent across pauses 
    -- the queue is supposed to empty after 40 seconds
    run_toggle_loop = true
    CreateTimeEvent("test_runner", "toggle_finite_runner_execution", 15, toggle_finite_runner)    
end

local function start_test_conditional()
    -- -- create a conditional runner wich will add a deck to the queue every 2 seconds
    npe_execution.Add(CLIENT_RUNNER_CONFIG.default_conditional)
    npe_execution.Resume(CLIENT_RUNNER_CONFIG.default_conditional.name)
end

local function start_test_exclusive()
    -- create an exclusive runner wich will add a deck to the queue every 2 seconds
    -- the exclusive runner will pause the non exclusive runner
    npe_execution.Add(CLIENT_RUNNER_CONFIG.non_exclusive_1)
    npe_execution.Add(CLIENT_RUNNER_CONFIG.non_exclusive_2)
    npe_execution.Add(CLIENT_RUNNER_CONFIG.exclusive_1)
    npe_execution.Resume(CLIENT_RUNNER_CONFIG.non_exclusive_1.name)
    npe_execution.Resume(CLIENT_RUNNER_CONFIG.non_exclusive_2.name)
    npe_execution.Resume(CLIENT_RUNNER_CONFIG.exclusive_1.name)
    CreateTimeEvent("test_runner", "toggle_exclusive_runner", 60, resume_exclusive_runner)
end

local test_started = false
local function client_on_update()
    if not test_started then -- only once
        printdebug(LOG.START, LOG.NPE_EXE," Start Client Test")
        test_started = true

        start_test_infinite()

        start_test_finite()

        start_test_conditional()

        start_test_exclusive()

        -- pause the runner after 180 seconds
        printlog(LOG.RGSTR, LOG.NPE_EXE," Schedule end of Test in 180 seconds")
        CreateTimeEvent("test_runner", "end_test", 100, end_test)
    end
end


function client_on_first_update()
    printlog(LOG.RUN, LOG.NPE_EXE," Client First Update")
end

if AddScriptCallback then
    AddScriptCallback("client_queue_empty")
end

-- end of client script

local function actor_on_first_update()
    -- start the execution manager
    
    npe_execution.Manager_start()
end

local function actor_on_net_destroy()
    -- 
    printlog(LOG.RUN, LOG.NPE_EXE," Actor Net Destroy")
    
end

function npe_on_log_update()
    printf("NPE EVENT LOG UPDATE")
    LOG = npe_manager.LOG
end

function on_game_start()
    -- test client registration
    RegisterScriptCallback("actor_on_first_update", client_on_first_update)
    RegisterScriptCallback("actor_on_update", client_on_update)
    RegisterScriptCallback("client_queue_empty", fill_queue)

    --- Execution Manager callbacks registration
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    -- RegisterScriptCallback("actor_on_update", actor_on_update)
    RegisterScriptCallback("npe_on_log_update", npe_on_log_update)
    RegisterScriptCallback("actor_on_net_destroy", actor_on_net_destroy)
end


-- TODO 
-- 1. Add a function to remove all runners
-- 2. Add a function to disable all runnners in a group but the runner with name = runner_name, given the group name and runner name
