
local printlog = npe_manager.Printlog_npe
local printdebug = npe_manager.Printdebug_npe
-- local print_table = npe_manager.Print_table_npe
LOG = npe_manager.LOG


local function print_table(t, indent)
    if not t then
        printlog(LOG.INFO, LOG.CONF, 'nil table')
        return
    end
    indent = indent or ''
    for key, value in pairs(t) do
        if type(value) == 'table' then
            printlog(LOG.INFO, LOG.CONF, indent .. '' .. key .. ':')
            print_table(value, indent .. '  ')
        else
            printlog(LOG.INFO, LOG.CONF, indent .. key .. ': ' .. tostring(value))
        end
    end
end

-- Execution Manager settings
local execution_manager_group_name = 'NPE_Execution_Manager'
local run_execution_manager_loop = false
local run_execution_manager_loop_name = 'NPE_Execution_Manager_Loop'
local execution_manager_loop = 0.5

-- Execition types

TYPE = {
    INFINITE = "INFINITE", -- never stops until disabled
    FINITE = "FINITE",  -- stop after a number of loops
    CONDITIONAL = "CONDITIONAL", -- stop when a condition is met
}   

-- runners instances

DEFAULT_RUNNER_CONFIG = {
    
    default_infinite = {
        execution = npe_execution.TYPE.INFINITE,
        timer = 1,
        loops = nil,
        stop_condition = nil,        
        functor = nil
    },
    default_finite = {
        execution = npe_execution.TYPE.FINITE,
        timer = 1,
        loops = 1,
        stop_condition = nil,        
        functor = nil
    },
    default_conditional = {
        execution = npe_execution.TYPE.CONDITIONAL,
        timer = 1,  -- make start_timer and add reset_timer
        loops = nil,
        stop_condition = nil,
        functor = nil
    }        
}

-- a template to create a new runner
local RUNNER_TEMPLATE = {
    default = {
        name = nil, -- set at creation
        config = nil, -- set at creation
        enabled = false,
        paused = false,
        running = false,
        exclusive = false,
        group_name = nil, 
        loop_count = 0, -- internal counter
    },  
}


-- the runners list
Runner = {}

-- runner local api

local function stop_runner(runner)
    if not Runner[runner.name].enabled then return end
    printdebug(LOG.REMOVE, LOG.NPE_EXE," Runner: " .. runner.name .. " disabled")
    Runner[runner.name].enabled = false
end

local function start_runner(runner)
    if Runner[runner.name].enabled then return end
    printdebug(LOG.ADD, LOG.NPE_EXE," Runner: " .. runner.name .. " enabled")
    Runner[runner.name].enabled = true
end

local function pause_runner(runner)
    if Runner[runner.name].paused then return end
    printdebug(LOG.ADD, LOG.NPE_EXE," Runner: " .. runner.name .. " paused")
    Runner[runner.name].enabled = false
    Runner[runner.name].paused = true
end

local function reset_state(runner)
    printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner.name .. " reset")
    Runner[runner.name].loop_count = 0
    Runner[runner.name].paused = false
end

local function set_running(runner)
    if Runner[runner.name].running then return end
    printdebug(LOG.START, LOG.NPE_EXE," Runner: " .. runner.name .. " running")
    Runner[runner.name].running = true
end

local function unset_running(runner)
    if not Runner[runner.name].running then return end
    printdebug(LOG.STOP, LOG.NPE_EXE," Runner: " .. runner.name .. " stopped")
    Runner[runner.name].running = false
end

local function is_enabled(runner)
    return Runner[runner.name].enabled
end

-- functor handler

local function validate_functor(functor)
    printdebug(LOG.RUN, LOG.NPE_EXE," Validate Functor")
    if not functor then return false end
    printdebug(LOG.INFO, LOG.NPE_EXE," Functor is not null")
    -- checks is a table
    if type(functor) ~= "table" then return false end
    printdebug(LOG.INFO, LOG.NPE_EXE," Functor is a table")
    -- checks mandatory fields (script, function)
    if #functor < 2 then return false end
    printdebug(LOG.INFO, LOG.NPE_EXE," Functor has at least 2 main parameters")
    if type(functor[1]) ~= "string" then return false end
    if type(functor[2]) ~= "string" then return false end
    printdebug(LOG.INFO, LOG.NPE_EXE," Functor script name and function name are strings")
    -- checks optional parameters
    if #functor < 3 then return true end
    printdebug(LOG.INFO, LOG.NPE_EXE," Functor has optional parameters")
    if type(functor[3]) ~= "table" then return false end
    printdebug(LOG.INFO, LOG.NPE_EXE," Functor optional parameters are a table")
    -- checks the number of parameters is correct
    -- the first parameter is the parameter count, will be ingored
    local param_count = #functor[3] - 1
    if functor[3][1] ~= param_count then return false end
    printdebug(LOG.INFO, LOG.NPE_EXE," Functor has " .. param_count .. " optional parameters")
    
    return true
end

local function inject_runner_name(functor, runner_name)
    functor[3][1] = runner_name
    -- table.insert(functor[3], 1, runner_name)
end

local execute_functor = function(params)
    -- the functor's handler or timed event
    -- these are perpetualy timed event which can only be stopped if runner is disabled
    -- usually the run function will stop the runner if certain conditions are met
    -- client scripts can stop the runner by calling the Pause/Remove functions
    -- print_table(params)
    local runner = params[1]
    -- check if the functor's runner has been removed, if so stop the execution
    if not runner then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner is null")
        return true 
    end
    printdebug(LOG.INFO, LOG.NPE_EXE," Evaluating Runner: " .. runner.name .. " Loop: " .. runner.loop_count)
    printdebug(LOG.RUN, LOG.NPE_EXE," Functor Execution: " .. runner.name)
    if not is_enabled(runner) then 
        -- the runner is disabled, stop the execution state of timed event
        -- we should not get here normally, unless for fast execution loops
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner is disabled")
        unset_running(runner)
        return true 
    end
    -- validate the functor's parameters
    if not runner.config.validated then
        local validation = validate_functor(runner.config.functor)
        if not validation then
            printdebug(LOG.ERROR, LOG.NPE_EXE," Functor parameters are invalid")
            printdebug(LOG.ERROR, LOG.NPE_EXE," Runner is disabled")
            unset_running(runner)
            return true
        end
        runner.config.validated = true
        inject_runner_name(runner.config.functor, runner.name)
    end
    -- reset this timed event timer for the next execution loop
    ResetTimeEvent(runner.group_name or execution_manager_group_name, runner.name, runner.config.timer)
    
    -- update the loop count
    runner.loop_count = runner.loop_count + 1
    printdebug(LOG.INFO, LOG.NPE_EXE," Executed Runner: " .. runner.name .. " Loop: " .. runner.loop_count)

    -- execute the functor
    -- print_table(runner.config.functor)
    execute_func(unpack(runner.config.functor))

    -- keeps running as long as the runner is enabled
    return false
end

-- runner handler

local function run(runner)
    if not runner and not runner.config then return end
    if runner.config.execution == nil then
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution type not defined")
        return
    end
    -- the runner has been enabled
    if not runner.running then
        -- instantiate if not running
        if runner.paused then
            -- runner was paused, remove the pause state
            runner.paused = false
        else
            -- reset the runner state
            reset_state(runner)
        end
        set_running(runner)
        CreateTimeEvent(runner.group_name or execution_manager_group_name, runner.name, runner.config.timer, execute_functor, { runner })
    else
        -- otherwise try to stop the runner
        if runner.config.execution == TYPE.INFINITE then
            -- do nothing, the runner is infinite
        elseif runner.config.execution == TYPE.FINITE then
            -- check the loop count
            if runner.loop_count >= runner.config.loops then
                printdebug(LOG.INFO, LOG.NPE_EXE," Reached maximum loops")
                -- terminate the runner
                stop_runner(runner)
            end
        elseif runner.config.execution == TYPE.CONDITIONAL then
            -- check the stop_condition is met
            if execute_func(unpack(runner.config.stop_condition)) then
                -- terminate the runner
                stop_runner(runner)
            end
        else
            printdebug(LOG.ERROR, LOG.NPE_EXE," Execution type " .. runner.config.execution .. " not supported")
        end
    end
end

-- Execution Manager or runners manager

local function execution_manager()
    if not run_execution_manager_loop then return true end -- stop the manager
    -- reset the timer
    ResetTimeEvent(execution_manager_group_name, run_execution_manager_loop_name, execution_manager_loop)

    -- for each Runner
    for runner_name, runner in pairs(Runner) do
        if runner.enabled then
            -- printdebug(LOG.RUN, LOG.NPE_EXE," Run: " .. runner_name)
            run(runner)
        end
    end
    
    -- keep running
    return false
end

-- Execution Manager Watch

local execution_watch_name = 'NPE_Execution_Manager_Watch'
local execution_watch_timer = 60
local run_execution_watch = false
local function execution_watch()
    printdebug(LOG.RUN, LOG.NPE_EXE," Execution Manager watch loop")
    if not run_execution_manager_loop then return true end -- stop the watch
    -- reset the timer
    ResetTimeEvent(execution_manager_group_name, execution_watch_name, execution_watch_timer)

    -- watch execution manager
    if run_execution_manager_loop then
        printlog(LOG.INFO, LOG.NPE_EXE," Execution Manager running")
    end
    -- watch runners
    for runner_name, runner in pairs(Runner) do
        printdebug(LOG.INFO, LOG.NPE_EXE," Runner: " .. runner_name .. " enabled: " .. tostring(runner.enabled) .. " running: " .. tostring(runner.running))
    end

    -- keep watching
    return false
end

local function watch()
    if run_execution_watch then return end
    run_execution_watch = true
    CreateTimeEvent(execution_manager_group_name, execution_watch_name, execution_watch_timer, execution_watch)
end

local function unwatch()
    if not run_execution_watch then return end
    run_execution_watch = false
    RemoveTimeEvent(execution_manager_group_name, execution_watch_name)
end

-- Execution Manager API

function Start()
    printlog(LOG.START, LOG.NPE_EXE," Execution Manager started")
    if run_execution_manager_loop then return end
    run_execution_manager_loop = true
    CreateTimeEvent(execution_manager_group_name, run_execution_manager_loop_name, execution_manager_loop, execution_manager)
    watch()
end

function Destroy()
    printlog(LOG.STOP, LOG.NPE_EXE," Execution Manager destroyed")
    if not run_execution_manager_loop then return end
    run_execution_manager_loop = false
    for runner_name, runner in pairs(Runner) do
        Remove(runner_name)
    end
    RemoveTimeEvent(execution_manager_group_name, run_execution_manager_loop_name)
    unwatch()
end

function Is_running()
    return run_execution_manager_loop
end

-- Runners' Execution API

-- creates runner instances

local function copy(obj, seen)
    if type(obj) ~= 'table' then return obj end
    if seen and seen[obj] then return seen[obj] end
    local s = seen or {}
    local res = setmetatable({}, getmetatable(obj))
    s[obj] = res
    for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
    return res
end
local function get_instance(runner_template)
    return copy(runner_template)
end



function Add(runner_name, runner_config)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    -- I need to add a new runner to the list Runner
    if not runner_name and not runner_config then return end

    if not Runner[runner_name] then
        -- create a new runner instance
        local new_runner_instance = get_instance(RUNNER_TEMPLATE.default)
        new_runner_instance.name = runner_name
        new_runner_instance.config = runner_config
        -- add the new runner to Runner list using runner_name as key
        Runner[runner_name] = new_runner_instance
        printdebug(LOG.ADD, LOG.NPE_EXE," Runner: " .. runner_name .. " added")
    else
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner: " .. runner_name .. " already exists")
    end
end

function Remove(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    -- I need to remove a runner from the list Runner
    if not runner_name then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Runner name is null")
        return 
    end
    local runner = Runner[runner_name]
    if runner then 
        RemoveTimeEvent(runner.group_name or execution_manager_group_name, runner.name)
        Runner[runner_name] = nil
        printdebug(LOG.REMOVE, LOG.NPE_EXE," Runner: " .. runner_name .. " removed")
    else
        printdebug(LOG.ERROR, LOG.NPE_EXE," Removing Runner: " .. runner_name .. " does not exist")
    end
end

function Stop(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if not runner_name then return end
    if Runner[runner_name] then
        stop_runner(Runner[runner_name])
    end
end

function Pause(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if not runner_name then return end
    if Runner[runner_name] then
        pause_runner(Runner[runner_name])
    end
end

function Resume(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if not runner_name then return end
    if Runner[runner_name] then
        start_runner(Runner[runner_name])
    end
end

-- runners utility API

function Get_runner_count(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] and Runner[runner_name].enabled then
        return Runner[runner_name].loop_count
    else
        return -1
    end
end

function Is_runner_running(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] then
        return Runner[runner_name].running
    else
        return false
    end
end

function Is_runner_enabled(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] then
        return Runner[runner_name].enabled
    else
        return false
    end
end

function Is_runner_paused(runner_name)
    if not Is_running() then 
        printdebug(LOG.ERROR, LOG.NPE_EXE," Execution Manager not running")
        return 
    end
    if Runner[runner_name] then
        return Runner[runner_name].paused
    else
        return false
    end
end

--- *********************************** CLIENT EXAMPLE SCRIPT *********************************** ---

-- this part belongs to a client script

local my_items_queue = {
    items = {},
}

-- a functor used to consume items from the queue and print them
-- operates in the client namespace context
function print_items(params)
    printdebug(LOG.RUN, LOG.NPE_EXE," Functor print_items")
    -- print_table(params)
    local runner_name = params[1]
    local param1 = params[2]
    local param2 = params[3]
    printdebug(LOG.INFO, LOG.NPE_EXE," Command: " .. param1)
    printdebug(LOG.INFO, LOG.NPE_EXE," Action: " .. param2)

    if my_items_queue.items and #my_items_queue.items > 0 then
        -- I need to remove the first item from the queue, and print it
        local item = table.remove(my_items_queue.items, 1)
        printdebug(LOG.INFO, LOG.NPE_EXE," Queue: " .. #my_items_queue.items)
        printdebug(LOG.INFO, LOG.NPE_EXE," Item: " .. item)
    else 
        printdebug(LOG.INFO, LOG.NPE_EXE," Items Queue is empty")
        npe_execution.Stop(runner_name)
        SendScriptCallback("client_queue_empty")
    end
    return true
end

local my_cards_queue = {
    cards = {},
}

-- a functor used to consume cards from the queue and print them
function print_cards(params)
    printdebug(LOG.RUN, LOG.NPE_EXE," Functor print_cards")
    -- print_table(params)
    local runner_name = params[1]
    local param1 = params[2]
    local param2 = params[3]
    printdebug(LOG.INFO, LOG.NPE_EXE," Command: " .. param1)
    printdebug(LOG.INFO, LOG.NPE_EXE," Action: " .. param2)

    if my_cards_queue.cards and #my_cards_queue.cards > 0 then
        -- I need to remove the first item from the queue, and print it
        local item = table.remove(my_cards_queue.cards, 1)
        printdebug(LOG.INFO, LOG.NPE_EXE," Queue: " .. #my_cards_queue.cards)
        printdebug(LOG.INFO, LOG.NPE_EXE," Card: " .. item)
    else 
        printdebug(LOG.INFO, LOG.NPE_EXE," Cards Queue is empty")
        npe_execution.Stop(runner_name)
    end
    return true
end


-- a function used to stop the runner conditionally after a number of loops
function maximum_loops(runner_name, loop_count)
    printdebug(LOG.RUN, LOG.NPE_EXE," Stop Condition")
    -- Client can use directly the npe_execution API
    if npe_execution.Get_runner_count(runner_name) >= loop_count then
        printdebug(LOG.INFO, LOG.NPE_EXE," Reached maximum loops")
        return true
    end
    return false
end

-- default runner configuration created by the client script

local CLIENT_RUNNER_CONFIG = {
    default_infinite = {
        execution = npe_execution.TYPE.INFINITE,
        timer = 30,
        loops = nil,
        condition = nil,        
        -- functionr interface 
        -- functor[1]: script name
        -- functor[2]: function name
        -- functor[3]: parameters
        -- functor[3][1]: parameters count (ignored)
        -- the functor execution handler will inject the runner name as the first parameter 
        functor = { "npe_execution", "print_items", {2, "run", "consume and print_items"} } 
    },
    default_finite = {
        execution = npe_execution.TYPE.FINITE,
        timer = 2,
        loops = 15,
        condition = nil,        
        functor = { "npe_execution", "print_cards", {2, "run", "consume and print_cards"} }
    },
    default_conditional = {
        execution = npe_execution.TYPE.CONDITIONAL,
        timer = 10,
        loops = nil,
        condition = { "npe_execution", "maximum_loops", {"default_conditional", 5} },  
        functor = { "npe_execution", "print_items", {2, "run", "default_conditional"} }
    }        
}


-- fill queue callback, shows how to resume the runner

local fill_count = 2
local function fill_queue()
    printlog(LOG.RUN, LOG.NPE_EXE," Fill Queue")
    if fill_count <= 0 then return end
    printdebug(LOG.INFO, LOG.NPE_EXE," Fill coount " .. fill_count)
    for i = 1, 10 do
        table.insert(my_items_queue.items, "item" .. tostring(i))
    end
    fill_count = fill_count - 1
    npe_execution.Resume("default_infinite")
end

-- client on actor update, shows how to add a runner and start it 

local function fill_test_queues()
    for i = 1, 20 do
        table.insert(my_items_queue.items, "item" .. tostring(i))
    end
    for i = 1, 20 do
        table.insert(my_cards_queue.cards, "card" .. tostring(i))
    end

end

local run_toggle_loop = false
local resumed_once = false
function toggle_finite_runner()
    printdebug(LOG.RUN, LOG.NPE_EXE," Toggle Finite Runner")
    if not run_toggle_loop then return true end
    ResetTimeEvent("test_runner", "toggle_finite_runner_execution", 10)
    if npe_execution.Is_running() then
        if not resumed_once then
            if npe_execution.Is_runner_enabled("default_finite") then
                -- pause the runner without resetting its state (loop count)
                npe_execution.Pause("default_finite")
            else
                npe_execution.Resume("default_finite")
                resumed_once = true
            end
        else
            -- stop the runner and resets its state (loop count)
            npe_execution.Stop("default_finite")
            run_toggle_loop = false
            RemoveTimeEvent("test_runner", "toggle_finite_runner_execution")
            return true
        end
    end
    -- keep running
    return false
end

-- end test callback, shows how to remove the runner

local function end_test()
    printlog(LOG.INFO, LOG.NPE_EXE," End Client Test")
    run_toggle_loop = false
    npe_execution.Remove("default_infinite")
    npe_execution.Remove("default_finite")
    npe_execution.Remove("default_conditional")
    -- print the table my_items_queue.items
    printdebug(LOG.INFO, LOG.NPE_EXE," Items Queue")
    print_table(my_items_queue.items)    
    -- print the table my_cards_queue.cards
    printdebug(LOG.INFO, LOG.NPE_EXE," Cards Queue")
    print_table(my_cards_queue.cards)
    return true
end

local test_started = false
local function client_on_update()
    if not test_started then -- only once
        printdebug(LOG.INFO, LOG.NPE_EXE," Start Client Test")
        test_started = true

        fill_test_queues()

        -- create an infinite runner wich will consume an item every 30 seconds
        npe_execution.Add("default_infinite", CLIENT_RUNNER_CONFIG.default_infinite)
        npe_execution.Resume("default_infinite")
    
        -- create an finite runner wich will consume 10 cards from the queue
        npe_execution.Add("default_finite", CLIENT_RUNNER_CONFIG.default_finite)
        npe_execution.Resume("default_finite")
        -- toggle the finite runner execution at 15 seconds in the run, to then pause it for 10 seconds
        -- this  to test that the loop count is persistent across pauses 
        -- the queue is supposed to empty after 40 seconds
        run_toggle_loop = true
        CreateTimeEvent("test_runner", "toggle_finite_runner_execution", 15, toggle_finite_runner)

        -- pause the runner after 180 seconds
        printlog(LOG.RGSTR, LOG.NPE_EXE," Schedule end of Test in 180 seconds")
        CreateTimeEvent("test_runner", "end_test", 180, end_test)
    end
end


function client_on_first_update()
    printlog(LOG.RUN, LOG.NPE_EXE," Client First Update")
end

if AddScriptCallback then
    AddScriptCallback("client_queue_empty")
end

-- end of client script

local function actor_on_first_update()
    -- start the execution manager
    
    npe_execution.Start()
end

local function actor_on_net_destroy()
    -- 
    printlog(LOG.RUN, LOG.NPE_EXE," Actor Net Destroy")
    Destroy()
end

function npe_on_log_update()
    printf("NPE EVENT LOG UPDATE")
    LOG = npe_manager.LOG
end

function on_game_start()
    -- test client registration
    RegisterScriptCallback("actor_on_first_update", client_on_first_update)
    RegisterScriptCallback("actor_on_update", client_on_update)
    RegisterScriptCallback("client_queue_empty", fill_queue)

    --- Execution Manager callbacks registration
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    -- RegisterScriptCallback("actor_on_update", actor_on_update)
    RegisterScriptCallback("npe_on_log_update", npe_on_log_update)
    RegisterScriptCallback("actor_on_net_destroy", actor_on_net_destroy)
end

-- TODO add to RUNNER_CONFIG 
-- start_timer (replaces timer)
-- reset_timer