
local printlog = npe_manager.Printlog_npe
local printdebug = npe_manager.Printdebug_npe
local LOG = npe_manager.LOG

GUI = nil -- instance, don't touch

GAMETIME_STATE = npe_dialog.GAMETIME_STATE
Sounds = npe_dialog.Sounds
local SOUNDS_SET = npe_dialog.MGS_CODEC -- codec dialog force use MGS_CODEC sounds

-- codec signal bands loop

DIRECTION_UP = 1
DIRECTION_DOWN = 0

local function set_codec_signal_band_to(level, direction)
	-- printdebug(LOG.INFO, LOG.UI_EXEC," set_codec_signal_band_to: " .. level .. " direction: " .. direction)
    if not GUI then return end
    local start, stop, step = 1, 9, 1
    if direction == DIRECTION_DOWN then
        start, stop, step = 9, 1, -1
    end
    for i = start, stop, step do
        GUI.codec_signal_band[i].enabled = (i <= level)
        if not GUI.codec_signal_band[i].enabled then
            GUI.codec_signal_band[i].mask:Show(true)
			-- printdebug(LOG.INFO, LOG.UI_EXEC," codec_signal_band[" .. i .. "] mask: Show(true)")
        else
            GUI.codec_signal_band[i].mask:Show(false)
			-- printdebug(LOG.INFO, LOG.UI_EXEC," codec_signal_band[" .. i .. "] mask: Show(false)")
        end
    end
end
function get_direction_str(direction)
	if direction == DIRECTION_UP then
		return "UP"
	else
		return "DOWN"
	end
end
local run_change_level_loop = false
local run_change_level_loop_name = 'NPE_change_level_Loop'
local change_level_loop = 0.15
local bootstrap_loop = 0.05
local bootstrapping = false
local direction
local target_level
local current_level
local codec_signal_manager_cooldown = 0
local MAX_LEVEL = 9
local MIN_LEVEL = 5
local BOOTSTRAP_LEVEL = 7
local MAX_LEVEL_CHANGE = 4
local function npe_run_change_level_loop()
	printdebug(LOG.RUN, LOG.POOL, LOG.UI_EXEC," run change level loop")
	if not run_change_level_loop then return true end
	if not GUI then return false end
	printdebug(LOG.RUN, LOG.UI_EXEC," change_level_loop current_level: " .. current_level .. " direction: " .. get_direction_str(direction) .. " target_level: " .. target_level)
	if (direction == DIRECTION_UP and current_level > target_level) or (direction == DIRECTION_DOWN and current_level < target_level) then 
		-- ends the loop
		printdebug(LOG.STOP, LOG.UI_EXEC," change_level loop ended ")
		if bootstrapping then
			bootstrapping = false
		end
		current_level = target_level
		run_change_level_loop = false
		codec_signal_manager_cooldown = time_global() + math.random(2, 6) * 250
		printdebug(LOG.INFO, LOG.UI_EXEC," codec_signal_manager_cooldown: " .. codec_signal_manager_cooldown)
		return true 
	end
    printdebug(LOG.INFO, LOG.UI_EXEC," change level loop - going " .. get_direction_str(direction))	

	local loop = change_level_loop
	if bootstrapping then
		loop = bootstrap_loop
	end
    ResetTimeEvent(run_change_level_loop_name, run_change_level_loop_name, loop)
	-- update current level
	set_codec_signal_band_to(current_level, direction)
	printdebug(LOG.INFO, LOG.UI_EXEC," current_level: " .. current_level .. " --> target_level: " .. target_level)
	if direction == DIRECTION_UP then
		current_level = current_level + 1
	else
		current_level = current_level - 1
	end
	-- continue loop
    return false
end

local function start_change_level_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," starting change level loop")
	if run_change_level_loop then return end
	run_change_level_loop = true
	local loop = change_level_loop
	if bootstrapping then
		printdebug(LOG.INFO, LOG.UI_EXEC," bootstrapping")
		direction = DIRECTION_UP
		target_level = BOOTSTRAP_LEVEL		
		loop = bootstrap_loop
	end	
	CreateTimeEvent(run_change_level_loop_name, run_change_level_loop_name, loop, npe_run_change_level_loop)
	printdebug(LOG.START, LOG.UI_EXEC," started change level loop")
end

local run_codec_signal_manager_loop = false
local run_codec_signal_manager_loop_name = 'NPE_codec_signal_manager_Loop'
local codec_signal_manager_loop = 0.5

local function npe_codec_signal_manager_loop()
	printdebug(LOG.RUN, LOG.POOL, LOG.UI_EXEC," run codec_signal_manager loop")
    if not run_codec_signal_manager_loop then return true end
	if not GUI then return false end
    ResetTimeEvent(run_codec_signal_manager_loop_name, run_codec_signal_manager_loop_name, codec_signal_manager_loop)
	printdebug(LOG.RUN, LOG.UI_EXEC," codec_signal_manager loop")
	-- codec signal band management
	if codec_signal_manager_cooldown == 0 and not run_change_level_loop then
		printdebug(LOG.INFO, LOG.UI_EXEC," current_level: " .. current_level)
		-- we need to decide if we go up or down
		direction = math.random(0, 9)
		if direction > 6 then
			direction = DIRECTION_UP
		elseif direction > 3 then
			direction = DIRECTION_DOWN
		else 
			-- 40% change for no change level
			return false
		end
		printdebug(LOG.INFO, LOG.UI_EXEC," random direction : " .. get_direction_str(direction))
		if direction == DIRECTION_UP and current_level == MAX_LEVEL then
			direction = DIRECTION_DOWN
			printdebug(LOG.INFO, LOG.UI_EXEC," overriding direction to: " .. get_direction_str(direction))
		elseif direction == DIRECTION_DOWN and current_level == MIN_LEVEL then
			direction = DIRECTION_UP
			printdebug(LOG.INFO, LOG.UI_EXEC," overriding direction to: " .. get_direction_str(direction))
		end
		-- how much to change the level
		local change_target_to = math.random(1, MAX_LEVEL_CHANGE) 
		printdebug(LOG.INFO, LOG.UI_EXEC," change_target_to: " .. change_target_to)
		if direction == DIRECTION_UP then
			target_level = math.min(current_level + change_target_to, MAX_LEVEL)
		else
			target_level = math.max(current_level - change_target_to, MIN_LEVEL)
		end
		-- start change level loop
		printdebug(LOG.INFO, LOG.UI_EXEC," start_change_level_loop current_level: " .. current_level .. " direction: " .. get_direction_str(direction) .. " target_level: " .. target_level)
		start_change_level_loop()
	else
		if time_global() > codec_signal_manager_cooldown then
			codec_signal_manager_cooldown = 0
		end
	end 

	-- continue loop
    return false
end

local function start_codec_signal_manager_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," starting codec_signal_manager loop")
    if run_codec_signal_manager_loop then return end
    run_codec_signal_manager_loop = true
	set_codec_signal_band_to(0,0)
	current_level = 0
	bootstrapping = true
    CreateTimeEvent(run_codec_signal_manager_loop_name, run_codec_signal_manager_loop_name, codec_signal_manager_loop, npe_codec_signal_manager_loop)
	printdebug(LOG.START, LOG.UI_EXEC," started change_level loop")
end

local function stop_codec_signal_manager_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," stopping codec_signal_manager loop")
	if not run_codec_signal_manager_loop then return end
	run_codec_signal_manager_loop = false
	codec_signal_manager_cooldown = 0
	run_change_level_loop = false
	printdebug(LOG.START, LOG.UI_EXEC," stopped codec_signal_manager loops")
end

-- Portraits flickering loops

clr_cache = {}

local function change_alpha(clr, a)
    if not (clr and a ) then return end

    if not clr_cache[clr .. "_" .. a] then
        b = bit.band(clr, 255)
        g = bit.band(bit.rshift(clr, 8), 255)
        r = bit.band(bit.rshift(clr, 16), 255)
        clr_cache[clr .. "_" .. a] = GetARGB(a, r, g, b)
    end

    return clr_cache[clr .. "_" .. a]
end


local CODEC_PORTAIT_DEFAULT_ALPHA = 220
local CODEC_PORTAIT_FLICKERING_ALPHA = 180

function change_portrait_alpha(portrait, a)
	if not portrait then return end
	local clr = portrait:GetTextureColor()
	change_alpha(clr, a)
	portrait:SetTextureColor(clr_cache[clr .. "_" .. a])
end

function get_flicker_chance()
	local chance = math.random(1, 100)
	if current_level < 7 then
		chance = chance + (7 - current_level) * 10
	elseif current_level == 9 then
		chance = chance - 50
	end
	return chance
end
-- caller portrait flickering loop

local run_caller_flickering_loop = false
local run_caller_flickering_loop_name = 'NPE_caller_flickering_Loop'
local caller_flickering_loop = 0.015
local caller_flickering_duration = 0
local function npe_caller_flickering_loop()
	printdebug(LOG.RUN, LOG.POOL, LOG.UI_EXEC," run caller_flickering loop")
    if not run_caller_flickering_loop then return true end
	if not GUI then return false end
	printdebug(LOG.RUN, LOG.UI_EXEC," caller_flickering loop")
	if time_global() > caller_flickering_duration then 
		-- ends the loop
		change_portrait_alpha(GUI.portrait_caller, CODEC_PORTAIT_DEFAULT_ALPHA)
		-- show portrait
		GUI.portrait_caller:Show(true)
		-- reset state
		run_caller_flickering_loop = false
		caller_flickering_duration = 0
		return true 
	end

    ResetTimeEvent(run_caller_flickering_loop_name, run_caller_flickering_loop_name, caller_flickering_loop)
	if GUI.portrait_caller:IsShown() then
		GUI.portrait_caller:Show(false)
	else
		GUI.portrait_caller:Show(true)
	end
	-- continue loop
    return false
end

local function start_caller_flickering_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," resuming caller_flickering loop")
    if run_caller_flickering_loop then return end
    run_caller_flickering_loop = true
	if not GUI then return false end
	change_portrait_alpha(GUI.portrait_caller, CODEC_PORTAIT_FLICKERING_ALPHA)
    CreateTimeEvent(run_caller_flickering_loop_name, run_caller_flickering_loop_name, caller_flickering_loop, npe_caller_flickering_loop) -- offset time caller_flickering_loop
	printdebug(LOG.START, LOG.UI_EXEC," resumed caller_flickering loop")
end

-- actor portrait flickering loop

local run_actor_flickering_loop = false
local run_actor_flickering_loop_name = 'NPE_actor_flickering_Loop'
local actor_flickering_loop = 0.015
local actor_flickering_duration = 0
local function npe_actor_flickering_loop()
	printdebug(LOG.RUN, LOG.POOL, LOG.UI_EXEC," run actor_flickering loop")
    if not run_actor_flickering_loop then return true end
	if not GUI then return false end
	if time_global() > actor_flickering_duration then 
		-- ends the loop
		change_portrait_alpha(GUI.portrait_caller, CODEC_PORTAIT_DEFAULT_ALPHA)
		GUI.portrait_actor:Show(true)
		run_actor_flickering_loop = false
		actor_flickering_duration = 0
		return true 
	end
    printdebug(LOG.RUN, LOG.UI_EXEC," actor_flickering loop")
    ResetTimeEvent(run_actor_flickering_loop_name, run_actor_flickering_loop_name, actor_flickering_loop)
	if GUI.portrait_actor:IsShown() then
		GUI.portrait_actor:Show(false)
	else
		GUI.portrait_actor:Show(true)
	end
	-- continue loop
    return false
end

local function start_actor_flickering_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," resuming actor_flickering loop")
    if run_actor_flickering_loop then return end
	if not GUI then return false end
	change_portrait_alpha(GUI.portrait_caller, CODEC_PORTAIT_FLICKERING_ALPHA)
    run_actor_flickering_loop = true
    CreateTimeEvent(run_actor_flickering_loop_name, run_actor_flickering_loop_name, actor_flickering_loop, npe_actor_flickering_loop) -- offset time actor_flickering_loop
	printdebug(LOG.START, LOG.UI_EXEC," resumed actor_flickering loop")
end

-- Portraits transparency manager loop

local run_portraits_scanlines_manager_loop = false
local run_portraits_scanlines_manager_loop_name = 'NPE_portraits_scanlines_manager_loop'
local portraits_scanlines_manager_loop = 1
local caller_flickering_cooldown = 0
local actor_flickering_cooldown = 0
local function npe_portraits_scanlines_manager_loop()
	printdebug(LOG.RUN, LOG.POOL, LOG.UI_EXEC," run portraits_scanlines_manager loop")
    if not run_portraits_scanlines_manager_loop then return true end
    ResetTimeEvent(run_portraits_scanlines_manager_loop_name, run_portraits_scanlines_manager_loop_name, portraits_scanlines_manager_loop)
	printdebug(LOG.RUN, LOG.UI_EXEC," portraits_scanlines_manager loop")
	-- caller scanlines loop management - cannot run if any scanline loop is active and it has a cooldown
	if caller_flickering_cooldown == 0 and not run_caller_flickering_loop and not run_actor_flickering_loop then
		-- start caller scanlines loop by chance			
		if get_flicker_chance() > 70 then
			caller_flickering_duration = time_global() + math.random(10, 50) * 5
			start_caller_flickering_loop()
			caller_flickering_cooldown = time_global() + math.random(1, 10) * 500
		end
	else 
		if time_global() > caller_flickering_cooldown then
			caller_flickering_cooldown = 0
		end
	end
	-- actor scanlines loop management - cannot run if any scanline loop is active and it has a cooldown
	if actor_flickering_cooldown == 0 and not run_actor_flickering_loop and not run_caller_flickering_loop then
		-- start actor scanlines loop by chance
		if get_flicker_chance() > 70 then
			actor_flickering_duration = time_global() + math.random(10, 50) * 5
			start_actor_flickering_loop()
			actor_flickering_cooldown = time_global() + math.random(1, 10) * 500
		end
	else 
		if time_global() > actor_flickering_cooldown then
			actor_flickering_cooldown = 0
		end
	end

    return false
end
local function stop_portraits_scanlines_manager_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," stopping portraits_scanlines_manager loop")
    if not run_portraits_scanlines_manager_loop then return end
    run_portraits_scanlines_manager_loop = false
	run_actor_flickering_loop = false
	run_caller_flickering_loop = false
	caller_flickering_cooldown = 0
	actor_flickering_cooldown = 0	
	printdebug(LOG.STOP, LOG.UI_EXEC," stopped portraits transparency loop")
end

local function start_portraits_scanlines_manager_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," starting portraits_scanlines_manager loop")
    if run_portraits_scanlines_manager_loop then return end
    run_portraits_scanlines_manager_loop = true
	run_actor_flickering_loop = false
	run_caller_flickering_loop = false
	caller_flickering_cooldown = 0
	actor_flickering_cooldown = 0		
    CreateTimeEvent(run_portraits_scanlines_manager_loop_name, run_portraits_scanlines_manager_loop_name, portraits_scanlines_manager_loop, npe_portraits_scanlines_manager_loop)
	printdebug(LOG.START, LOG.UI_EXEC," started portraits transparency loop")
end

-- portraits secondary scanlines loop

local run_portrait_scanlines_loop = false
local portrait_scanlines_loop_name = 'NPE_portrait_scanlines_loop_Loop'
local portrait_scanlines_loop = 0.015
local portrait_scanlines_loop_count = 0
local starting_y = 0
local ending_y = 193
local function npe_portrait_scanlines_loop()
	printdebug(LOG.RUN, LOG.POOL, LOG.UI_EXEC," run portrait_scanlines loop")
    if not run_portrait_scanlines_loop then return true end
	if not GUI then return false end
    ResetTimeEvent(portrait_scanlines_loop_name, portrait_scanlines_loop_name, portrait_scanlines_loop) -- offset time context_countdowns_loop
	printdebug(LOG.RUN, LOG.UI_EXEC," portrait scanlines loop")
	portrait_scanlines_loop_count = portrait_scanlines_loop_count + 1
	if portrait_scanlines_loop_count > 1000 then portrait_scanlines_loop_count = 0 end
	if (portrait_scanlines_loop_count % 2 == 0) then
		-- update big scanlines at half frequency
		local x_l = GUI.codec_scanline_big_l:GetWndPos().x
		local x_r = GUI.codec_scanline_big_r:GetWndPos().x
		local y = GUI.codec_scanline_big_l:GetWndPos().y
		y = y + 1
		-- printdebug(LOG.INFO, LOG.UI_EXEC," portrait scanlines loop y: " .. y)
		if y > ending_y then y = starting_y end
		GUI.codec_scanline_big_l:SetWndPos(vector2():set(x_l, y))
		GUI.codec_scanline_big_r:SetWndPos(vector2():set(x_r, y))			
	end
	-- update scanlines
	local x_l = GUI.codec_scanline_l:GetWndPos().x
	local x_r = GUI.codec_scanline_r:GetWndPos().x
	local y = GUI.codec_scanline_l:GetWndPos().y
	y = y + 1
	-- printdebug(LOG.INFO, LOG.UI_EXEC," portrait scanlines loop y: " .. y)
	if y > ending_y then y = starting_y end
	GUI.codec_scanline_l:SetWndPos(vector2():set(x_l, y))
	GUI.codec_scanline_r:SetWndPos(vector2():set(x_r, y))	
	return false
end

local function start_portrait_scanlines_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," starting portrait scanlines loop")
    if run_portrait_scanlines_loop then return end
	if not GUI then return end
    run_portrait_scanlines_loop = true
	starting_y = GUI.codec_scanline_l:GetWndPos().y
    CreateTimeEvent(portrait_scanlines_loop_name, portrait_scanlines_loop_name, portrait_scanlines_loop, npe_portrait_scanlines_loop)
	printdebug(LOG.START, LOG.UI_EXEC," started portrait scanlines loop")
end

local function stop_portrait_scanlines_loop()
	printdebug(LOG.RUN, LOG.UI_EXEC," stopping portrait scanlines loop")
    if not run_portrait_scanlines_loop then return end
    run_portrait_scanlines_loop = false
	portrait_scanlines_loop_count = 0
	printdebug(LOG.STOP, LOG.UI_EXEC," stopped portrait scanlines loop")
end

-- open codec dialog function as callback or timed event

local function open_codec_dialog_ui(set)
    printdebug(LOG.INFO, LOG.UI," Play set module: " .. set.module .. " set Id:" .. set.id)
	printdebug(LOG.INFO, LOG.UI," Play set title: " .. set.title)
	printdebug(LOG.INFO, LOG.UI," Sounds set: " .. SOUNDS_SET)
    printdebug(LOG.INFO, LOG.UI," Creating GUI")
    GUI = UINewPlayerExperience(set)

	if (GUI) and (not GUI:IsShown()) then
        printdebug(LOG.INFO, LOG.UI," Showing GUI")
		GUI:ShowDialog(true)
		Register_UI("UINewPlayerExperience","npe_dialog")
		GUI:DoStartActions()
		start_portrait_scanlines_loop()
		start_portraits_scanlines_manager_loop()
		start_codec_signal_manager_loop()
		npe_dialog.Enable_dof()
    else
        printdebug(LOG.INFO, LOG.UI," GUI already shown")
		npe_manager.Resume_execution()
    end	
end

local function open_codec_dialog(set, callback)

	local f
    f = function() 
	printdebug(LOG.INFO, LOG.UI," open_codec_dialog callback: " .. callback)
	if callback then
		printdebug(LOG.REMOVE, LOG.RGSTR," Unregistering callback [" ..callback .. "]")
		UnregisterScriptCallback(callback, f)
	end

	open_codec_dialog_ui(set)

	end
	return f
end

local function open_codec_dialog_te(set)
	printlog(LOG.INFO, LOG.UI," open_codec_dialog_te")
	open_codec_dialog_ui(set)
	return true
end

-- detector equip functions

local function equip_anomaly_radio(set)
	printdebug(LOG.INFO, LOG.UI," equip_anomaly_radio")

	-- register callback to detector on equipping
	local callback_name = "npe_dialog_codec_open_detector"
	AddScriptCallback(callback_name)
	RegisterScriptCallback(callback_name,open_codec_dialog(set, callback_name))
	npe_actions.set_callback_on_equip(callback_name)

	-- configure radio ui and sounds 
	if set.codec_frequency then
		npe_actions.set_radio_freq(math.floor(set.codec_frequency))
	end	
	npe_actions.Mute_radio(true)
	npe_actions.set_detector_open_sound(Sounds[SOUNDS_SET].open)

	-- start equipping animation
	npe_actions.select_detector(npe_actions.Devices.radio)
end


local function equip_nerfs_radio(nerfs_radio_type,set)
	printdebug(LOG.INFO, LOG.UI," equip_nerfs_radio radio_type: " .. nerfs_radio_type)
	local open_time
	local sound_time
	-- configure radio ui and sounds 
	if set.codec_frequency then
		npe_actions.set_radio_freq(math.floor(set.codec_frequency))
	end	
	npe_actions.Mute_radio(true)
	if nerfs_radio_type == npe_actions.RADIO_TYPE.NERFS then 
		open_time = 0.5
		sound_time = 0.5
	else
		open_time = 1.3
		sound_time = 1.3
	end
	printdebug(LOG.INFO, LOG.UI," Play open sound after delay %s", sound_time)
	CreateTimeEvent("npe_dialog_codec", "play_open_sound", sound_time, npe_dialog.Play_sound, Sounds[SOUNDS_SET].open)

	-- prep timed event for open_codec_dialog ui
	CreateTimeEvent("npe_dialog_codec", "open_codec_dialog_te", open_time, open_codec_dialog_te, set)

	-- start equipping animation
	npe_actions.select_detector(npe_actions.Devices.radio)
end

-- codec call loop functions

local run_codec_call_loop = false
local codec_call_loop_name = 'NPE_codec_call_Loop'
local codec_ring_count = 0
local codec_ring_count_answer = 3

local function codec_call_loop(set)
	printdebug(LOG.RUN, LOG.POOL, LOG.UI_EXEC," run codec call loop")
    if not run_codec_call_loop then return true end
	printdebug(LOG.RUN, LOG.UI_EXEC," codec call loop")
	npe_dialog.Play_sound(Sounds[SOUNDS_SET].call)
	codec_ring_count = codec_ring_count + 1
	printdebug(LOG.INFO, LOG.UI_EXEC," codec_ring_count: " .. codec_ring_count)
	if codec_ring_count < codec_ring_count_answer then
		-- play another ring tune
    	ResetTimeEvent(codec_call_loop_name, codec_call_loop_name, 2)
		return
	end

	-- reset state
	printdebug(LOG.STOP, LOG.UI_EXEC," codec call loop ended ")
	run_codec_call_loop = false
	codec_ring_count = 0

	-- handle radio type
	local radio_type = npe_actions.Get_radio_type()
	printdebug(LOG.INFO, LOG.UI_EXEC," Play open sound for radio_type: " .. radio_type)
	if radio_type == npe_actions.RADIO_TYPE.VANILLA then
		equip_anomaly_radio(set)
	else
		equip_nerfs_radio(radio_type,set)
	end

	-- returns true to stop the loop automatically 
    return true
end

local function start_codec_call_loop(set)
	printdebug(LOG.RUN, LOG.UI_EXEC," starting codec call loop")
    if run_codec_call_loop then return end
    run_codec_call_loop = true
	codec_ring_count = 0
    CreateTimeEvent(codec_call_loop_name, codec_call_loop_name, 1, codec_call_loop, set)
	printdebug(LOG.START, LOG.UI_EXEC," started codec call loop")
end

-- api to start the codec dialog

function Play(set)
	if set == nil then
		printdebug(LOG.INFO, LOG.UI," Play set is nil")
		npe_manager.Resume_execution()
		return
	end
	npe_manager.Register_dialog(set.dialog)

	start_codec_call_loop(set)
end



local xml = nil
function LoadUIStatic(dialog)
	printdebug(LOG.INFO, LOG.UI," LoadUIStatic")
	if not xml then
		printdebug(LOG.INFO, LOG.UI," Loading " .. dialog .. ".xml")
		xml = CScriptXmlInit()
		xml:ParseFile(dialog .. ".xml")
	end
	return xml
end

-------------------------------------------------------------------
class "UINewPlayerExperience" (CUIScriptWnd)

function UINewPlayerExperience:__init(set) super()
	self:InitControls(set)
end

function UINewPlayerExperience:__finalize()
end

function UINewPlayerExperience:InitControls(set)
    printdebug(LOG.INFO, LOG.UI," Init Codec UI")
	self:SetWndRect			(Frect():set(0,0,1024,768))
	self:SetAutoDelete(true)
	self.set = set
    LoadUIStatic(set.dialog)
    self.xml = xml
	if not xml then
		printdebug(LOG.INFO, LOG.UI," Error loading " .. set.dialog .. ".xml")
		return
	end

	printdebug(LOG.INFO, LOG.UI," Creating Codec frame")
	self.dialog	= xml:InitStatic(set.dialog, self)
	self.frame	= xml:InitFrame(set.dialog .. ":frame", self.dialog)

	self.codec_bg = xml:InitStatic(set.dialog .. ":codec_bg",self.dialog)
	self.codec_signal_band = {
		[1] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band1",self.dialog)},
		[2] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band2",self.dialog)},
		[3] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band3",self.dialog)},
		[4] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band4",self.dialog)},
		[5] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band5",self.dialog)},
		[6] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band6",self.dialog)},
		[7] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band7",self.dialog)},
		[8] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band8",self.dialog)},
		[9] = {enabled = false , mask = xml:InitStatic(set.dialog .. ":codec_band9",self.dialog)},
	} 

	local text
	text = game.translate_string(self.set.title)
	self.set_title = xml:InitTextWnd(set.dialog .. ":set_title",self.dialog)
	self.set_title:SetText(text)

    self.codec_frequency = xml:InitTextWnd(set.dialog .. ":codec_frequency",self.dialog)
	self.codec_frequency:SetFont(GetFontGraffiti50Russian())
	self.codec_frequency:SetText(self.set.codec_frequency)

	-- card context
	self.cardIndex = 1
	if self.set.cards[self.cardIndex] then
		printdebug(LOG.INFO, LOG.UI," Creating Codec cards panel")

		self.portrait_caller = xml:InitStatic(set.dialog .. ":portrait_caller",self.dialog)
		self.portrait_caller:InitTexture(self.set.cards[self.cardIndex].portrait_caller)

		self.portrait_actor = xml:InitStatic(set.dialog .. ":portrait_actor",self.dialog)
		self.portrait_actor:InitTexture(self.set.cards[self.cardIndex].portrait_actor)		

		self.codec_scanline_l = xml:InitStatic(set.dialog .. ":codec_scanline_l",self.dialog)
		self.codec_scanline_r = xml:InitStatic(set.dialog .. ":codec_scanline_r",self.dialog)
		
		self.codec_scanline_big_l = xml:InitStatic(set.dialog .. ":codec_scanline_big_l",self.dialog)
		self.codec_scanline_big_r = xml:InitStatic(set.dialog .. ":codec_scanline_big_r",self.dialog)	

		self.card_title = xml:InitTextWnd(set.dialog .. ":card_title",self.dialog)
		self.message = xml:InitTextWnd(set.dialog .. ":message",self.dialog)

		self:PlayCard()
	end

	printdebug(LOG.INFO, LOG.UI," Creating Codec controls")

	-- btn_continue
    self.btn_continue = xml:Init3tButton(set.dialog .. ":btn_continue", self.dialog)
	self:Register(self.btn_continue, "btn_continue")	
	self:AddCallback("btn_continue", ui_events.BUTTON_CLICKED, self.OnButtonContinue, self)

	-- btn_close
    self.btn_close = xml:Init3tButton(set.dialog .. ":btn_close", self.dialog)
	self:Register(self.btn_close, "btn_close")	
	self:AddCallback("btn_close", ui_events.BUTTON_CLICKED, self.OnButtonClose, self)

	printdebug(LOG.INFO, LOG.UI," Rendering Codec UI")
	self:PositionWindow()
	self:UpdateButtons()
end

local ratio = (device().height / device().width) / (768 / 1024) 
function UINewPlayerExperience:PositionWindow()
	ratio = (device().height / device().width) / (768 / 1024) 
	printdebug(LOG.INFO, LOG.UI," PositionWindow ratio: " .. ratio)
	local x_translate = 200 * ratio
	local y_translate =  100 * ratio

	local pos = self.dialog:GetWndPos()
	self.dialog:SetWndPos( vector2():set(pos.x + x_translate, pos.y - 8 + y_translate))
end

function UINewPlayerExperience:DoStartActions()
	printdebug(LOG.INFO, LOG.UI," DoStartActions")

	if self.set.start_actions then
		for i, action in pairs(self.set.start_actions) do
			npe_manager.Execute_npe_action(action, self.set.id)
		end
	
	end
end

function UINewPlayerExperience:DoEndActions()
	printdebug(LOG.INFO, LOG.UI," DoEndActions")

	if self.set.end_actions then
		for i, action in pairs(self.set.end_actions) do
			npe_manager.Execute_npe_action(action, self.set.id)
		end
	
	end
end

function UINewPlayerExperience:PlayCard()
	printdebug(LOG.INFO, LOG.UI," PlayCard")
	local text

	-- update card context
	if self.set.cards[self.cardIndex].title then
		text = game.translate_string(self.set.cards[self.cardIndex].title)
	else
		text = game.translate_string(self.set.title)
	end
	self.card_title:SetText(text)

	-- update portraits

	self.portrait_caller:InitTexture(self.set.cards[self.cardIndex].portrait_caller)
	self.portrait_actor:InitTexture(self.set.cards[self.cardIndex].portrait_actor)	

	-- update card message
	text = game.translate_string(self.set.cards[self.cardIndex].message)
	self.message:SetText(text)

	-- play start sound
	local start_sound_delay = 0
	local tts_starting_delay = 0
	if self.set.cards[self.cardIndex].start_sound then 
		start_sound_delay = 0.5
		tts_starting_delay = self.set.cards[self.cardIndex].start_sound.duration
		npe_dialog.Play_sound_with_delay(self.set.cards[self.cardIndex].start_sound.sound, start_sound_delay)
	end
	
	-- play text to speech sounds
	local tts_sounds = self.set.cards[self.cardIndex].tts_sounds
	if tts_sounds then
		local starting_delay = start_sound_delay + tts_starting_delay
		for i = 1, #tts_sounds do
			npe_dialog.Play_sound_with_delay(tts_sounds[i].sound, starting_delay)
			starting_delay = starting_delay + tts_sounds[i].duration + 1
		end
	end
	local start_sound_delay = 0
	local tts_starting_delay = 0
end

function UINewPlayerExperience:UpdateButtons()
	printdebug(LOG.INFO, LOG.UI," UpdateButtons")

	if self.cardIndex < #self.set.cards then
		self.btn_continue:Show(true)
		self.btn_close:Show(false)
	end

	if self.cardIndex == #self.set.cards then
		self.btn_continue:Show(false)
		self.btn_close:Show(true)
	end
end

function UINewPlayerExperience:OnButtonClose()
    self:Close()
end

function UINewPlayerExperience:OnButtonContinue()
    printdebug(LOG.INFO, LOG.UI," OnButtonContinue")
	self.cardIndex = self.cardIndex + 1
	if self.cardIndex <= #self.set.cards and self.set.cards[self.cardIndex] then

		self:PlayCard()
	else
		self.cardIndex = #self.set.cards
	end
	self:UpdateButtons()
end

local closing_dialog = false
local function close_dialog(dialog)
	printdebug(LOG.STOP, LOG.UI," close_dialog_after_delay")
	stop_portrait_scanlines_loop()
	stop_portraits_scanlines_manager_loop()
	stop_codec_signal_manager_loop()
	npe_dialog.Disable_dof()
	GUI:DoEndActions()
	GUI:HideDialog()
	GUI:Show(false)
	Unregister_UI("UINewPlayerExperience")
	GUI = nil    
	npe_manager.Unregister_dialog(dialog)
	npe_manager.Resume_execution()
	closing_dialog = false
	return true
end

local function unequip_nerfs_radio(radio_type, dialog)
	printdebug(LOG.INFO, LOG.UI," unequip_nerfs_radio radio_type: " .. radio_type)
	npe_actions.Unequip_detector()
	if radio_type == npe_actions.RADIO_TYPE.NERFS then
		local close_time = 0
		local unmute_time = 2
		CreateTimeEvent("npe_dialog_codec", "play_close_sound", close_time, npe_dialog.Play_sound, Sounds[SOUNDS_SET].close)
		CreateTimeEvent("npe_dialog_codec", "unmute_anomaly_radio", unmute_time, npe_actions.Mute_radio, false)
		CreateTimeEvent("npe_dialog_codec", "close_dialog", close_time, close_dialog, dialog)
	else
		local close_time = 0.9
		local close_snd_time = 0.8
		local unmute_time = 2
		printdebug(LOG.INFO, LOG.UI," Play close sound after delay %s", close_time)
		CreateTimeEvent("npe_dialog_codec", "play_close_sound", close_snd_time, npe_dialog.Play_sound, Sounds[SOUNDS_SET].close)
		CreateTimeEvent("npe_dialog_codec", "unmute_anomaly_radio", unmute_time, npe_actions.Mute_radio, false)
		CreateTimeEvent("npe_dialog_codec", "close_dialog", close_time, close_dialog, dialog)
	end
end

local function unequip_anomaly_radio(dialog)
	printdebug(LOG.INFO, LOG.UI," unequip_anomaly_radio")
	npe_actions.Unequip_detector()
	local close_time = 0
	local unmute_time = 2
	CreateTimeEvent("npe_dialog_codec", "play_close_sound", close_time, npe_dialog.Play_sound, Sounds[SOUNDS_SET].close)
	CreateTimeEvent("npe_dialog_codec", "unmute_anomaly_radio", unmute_time, npe_actions.Mute_radio, false)
	CreateTimeEvent("npe_dialog_codec", "close_dialog", close_time, close_dialog, dialog)
end

-- can be used as timed event callback or direct call

local function unequip_radio(dialog)
	-- handle radio type
	local radio_type = npe_actions.Get_radio_type()
	printdebug(LOG.INFO, LOG.UI," Play open sound for radio_type: " .. radio_type)
	if radio_type == npe_actions.RADIO_TYPE.VANILLA then
		unequip_anomaly_radio(dialog)
	else
		unequip_nerfs_radio(radio_type, dialog)
	end

	return true
end 

function UINewPlayerExperience:Save()
	if self.set.save_context then
		printdebug(LOG.INFO, LOG.UI," Save context")
		local context = self.set.save_context
		-- if context.set_completion then
		-- 	local id = self.set.id .. "/set_completion"
		-- 	npe_mcm.npe_module_set_setting(self.set.module, id, true)
		-- end
	end
end

function UINewPlayerExperience:Close()
	if not closing_dialog then
		closing_dialog = true
		if self.set.save_context then
			self:Save()
		end
		if self.set.completion_sound then 
			-- we have the set's completion sound to play, un-equip radio with a delay equal to its duration
			npe_dialog.Play_sound(self.set.completion_sound.sound)
			CreateTimeEvent("npe_dialog_codec", "unequip_radio", self.set.completion_sound.duration, unequip_radio, self.set.dialog)
		else
			-- delay is 0
			unequip_radio(self.set.dialog)
		end
	end
end

function UINewPlayerExperience:TearDown()
	self:HideDialog()
	self:Show(false)
	Unregister_UI("UINewPlayerExperience")
	GUI = nil    
end
function UINewPlayerExperience:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
			if dik == DIK_keys.DIK_SPACE then
				if self.cardIndex == #self.set.cards then
					self:Close()
				else
					self:OnButtonContinue()					
				end
			end			
		end
    end
    return res
end

function npe_on_log_update()
    printf("NPE EVENT LOG UPDATE")
    LOG = npe_manager.LOG
end

function on_game_start()
    RegisterScriptCallback("npe_on_log_update", npe_on_log_update)
end